{
  "language": "Solidity",
  "sources": {
    "contracts/capTable/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ncontract Controllable {\n    address[] internal _controllers;\n    mapping(address => bool) internal _isController;\n\n    constructor(address[] memory controllers) public {\n        _setControllers(controllers);\n    }\n\n    function controllers() external view returns (address[] memory) {\n        return _controllers;\n    }\n\n    function setControllers(address[] calldata operators) external {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        _setControllers(operators);\n    }\n\n    function isController(address adr) public view returns (bool) {\n        return _isController[adr];\n    }\n\n    function _setControllers(address[] memory adresses) internal {\n        for (uint256 i = 0; i < _controllers.length; i++) {\n            _isController[_controllers[i]] = false;\n        }\n        for (uint256 j = 0; j < adresses.length; j++) {\n            _isController[adresses[j]] = true;\n        }\n        _controllers = adresses;\n    }\n}\n"
    },
    "contracts/capTable/CapTableRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./Controllable.sol\";\n\ncontract CapTableRegistry is Controllable {\n    address[] internal _capTables;\n    mapping(address => uint256) internal _status; // 0:notUsed 1:qued 2:approved 3:declined 4:removed\n    mapping(address => bytes32) internal _addressToUuid;\n    mapping(bytes32 => address) internal _uuidToAddress;\n    mapping(bytes32 => address) internal _uuidToQuedAddress;\n    uint256 internal _activeCapTables;\n    uint256 internal _quedCapTables;\n\n    event capTableQued(address indexed capTableAddress, bytes32 indexed _uuid);\n    event capTableApproved(address indexed capTableAddress);\n    event capTableRemoved(address indexed capTableAddress);\n    event capTableDeclined(address indexed capTableAddress, bytes32 reason);\n\n    constructor(address[] memory controllers)\n        public\n        Controllable(controllers)\n    {}\n\n    function que(address adr, bytes32 uuid) external {\n        _queCapTable(adr, uuid);\n    }\n\n    function approve(address adr) external {\n        _approveCapTable(adr);\n    }\n\n    function decline(address adr, bytes32 reason) external {\n        _declineCapTable(adr, reason);\n    }\n\n    function remove(address adr) external {\n        _removeCapTable(adr);\n    }\n\n    function getActiveCount() external view returns (uint256 activeCapTables) {\n        return _activeCapTables;\n    }\n\n    function getQuedCount() external view returns (uint256 quedCapTables) {\n        return _quedCapTables;\n    }\n\n    function getList() external view returns (address[] memory capTableList) {\n        return _capTables;\n    }\n\n    function getUuid(address adr) external view returns (bytes32 uuid) {\n        return _addressToUuid[adr];\n    }\n\n    function getStatus(address adr) external view returns (uint256 status) {\n        return _status[adr];\n    }\n\n    function getAddress(bytes32 uuid)\n        external\n        view\n        returns (address capTableAddress)\n    {\n        return _uuidToAddress[uuid];\n    }\n\n    // REVIEW : Only a helper function to retreive last qued address for an UUID. Somone can easily overwrite this, so its not safe. Can lead to confusion it result is not properly checked.\n    function getLastQuedAddress(bytes32 uuid)\n        external\n        view\n        returns (address capTableAddress)\n    {\n        return _uuidToQuedAddress[uuid];\n    }\n\n    function info(address adr)\n        external\n        view\n        returns (bytes32 uuid, uint256 active)\n    {\n        return (_addressToUuid[adr], _status[adr]);\n    }\n\n    function _queCapTable(address adr, bytes32 uuid) internal {\n        require(\n            _status[adr] != 1,\n            \"Qued capTables must be declined before reQue\"\n        );\n        require(_status[adr] != 2, \"Cannot que active capTable\");\n        _capTables.push(adr);\n        _status[adr] = 1;\n        _addressToUuid[adr] = uuid;\n        _uuidToQuedAddress[uuid] = adr;\n        _quedCapTables++;\n        emit capTableQued(adr, uuid);\n    }\n\n    function _approveCapTable(address adr) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be approved\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 2;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToAddress[uuid] = adr;\n        _uuidToQuedAddress[uuid] = address(0);\n        _quedCapTables--;\n        _activeCapTables++;\n        emit capTableApproved(adr);\n    }\n\n    function _declineCapTable(address adr, bytes32 reason) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be declined\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 3;\n        _quedCapTables--;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToQuedAddress[uuid] = address(0);\n        emit capTableDeclined(adr, reason);\n    }\n\n    function _removeCapTable(address adr) internal {\n        require(_status[adr] == 2, \"Only approved capTables can be removed\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 4;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToAddress[uuid] = address(0);\n        _activeCapTables--;\n        emit capTableRemoved(adr);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}