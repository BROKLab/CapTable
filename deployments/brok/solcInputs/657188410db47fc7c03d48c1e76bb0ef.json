{
  "language": "Solidity",
  "sources": {
    "contracts/capTable/CapTableFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\nimport \"./../ERC1400.sol\";\nimport \"./CapTableRegistry.sol\";\nimport \"./Controllable.sol\";\n\ncontract CapTableFactory {\n    CapTableRegistry internal _capTableRegistry;\n    uint256 internal _defaultGranularity;\n    address[] internal _defaultControllers;\n    bytes32[] internal _defaultPartitions;\n\n    constructor(address capTableRegistryAddress) public {\n        _defaultGranularity = 1;\n        _defaultControllers.push(0xbbb7a6CC5b0757d60A457f2a1A667Aa53A13F515);\n        _defaultPartitions.push(\n            0x6f7264696ec3a672650000000000000000000000000000000000000000000000\n        ); // ordinære\n        _defaultControllers.push(address(0));\n        _capTableRegistry = CapTableRegistry(capTableRegistryAddress);\n    }\n\n    function getCapTableRegistryAddress()\n        public\n        view\n        returns (address capTableRegistryAddress)\n    {\n        return address(_capTableRegistry);\n    }\n\n    // REVIEW : Only a helper function to retreive last qued address for an UUID. Somone can easily overwrite this, so its not safe. Can lead to confusion it result is not properly checked.\n    function getLastQuedAddress(bytes32 uuid)\n        external\n        view\n        returns (address quedCapTableRegistryAddress)\n    {\n        return _capTableRegistry.getLastQuedAddress(uuid);\n    }\n\n    function createCapTable(\n        bytes32 uuid,\n        string calldata name,\n        string calldata symbol\n    ) external {\n        _defaultControllers[1] = msg.sender; // REVIEW IS THIS SAFE?\n        bytes32[] memory defaultPartitions = _defaultPartitions;\n        ERC1400 capTable =\n            new ERC1400(\n                name,\n                symbol,\n                _defaultGranularity,\n                _defaultControllers,\n                defaultPartitions\n            );\n        capTable.addMinter(msg.sender);\n        capTable.removeMinter(address(this));\n        capTable.transferOwnership(msg.sender);\n        _capTableRegistry.que(address(capTable), uuid);\n    }\n}\n"
    },
    "contracts/ERC1400.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ERC1820/ERC1820Client.sol\";\nimport \"./interface/ERC1820Implementer.sol\";\n\nimport \"./roles/MinterRole.sol\";\n\nimport \"./IERC1400.sol\";\n\n// Extensions\nimport \"./extensions/tokenExtensions/IERC1400TokensValidator.sol\";\nimport \"./extensions/tokenExtensions/IERC1400TokensChecker.sol\";\nimport \"./extensions/userExtensions/IERC1400TokensSender.sol\";\nimport \"./extensions/userExtensions/IERC1400TokensRecipient.sol\";\n\n/**\n * @title ERC1400\n * @dev ERC1400 logic\n */\ncontract ERC1400 is\n    IERC20,\n    IERC1400,\n    Ownable,\n    ERC1820Client,\n    ERC1820Implementer,\n    MinterRole\n{\n    using SafeMath for uint256;\n\n    // Token\n    string internal constant ERC1400_INTERFACE_NAME = \"ERC1400Token\";\n    string internal constant ERC20_INTERFACE_NAME = \"ERC20Token\";\n\n    // Token extensions\n    string internal constant ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\n    string internal constant ERC1400_TOKENS_VALIDATOR =\n        \"ERC1400TokensValidator\";\n\n    // User extensions\n    string internal constant ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n    string internal constant ERC1400_TOKENS_RECIPIENT =\n        \"ERC1400TokensRecipient\";\n\n    /************************************* Token description ****************************************/\n    string internal _name;\n    string internal _symbol;\n    uint256 internal _granularity;\n    uint256 internal _totalSupply;\n    bool internal _migrated;\n    /************************************************************************************************/\n\n    /**************************************** Token behaviours **************************************/\n    // Indicate whether the token can still be controlled by operators or not anymore.\n    bool internal _isControllable;\n\n    // Indicate whether the token can still be issued by the issuer or not anymore.\n    bool internal _isIssuable;\n    /************************************************************************************************/\n\n    /********************************** ERC20 Token mappings ****************************************/\n    // Mapping from tokenHolder to balance.\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from (tokenHolder, spender) to allowed value.\n    mapping(address => mapping(address => uint256)) internal _allowed;\n    /************************************************************************************************/\n\n    /**************************************** Documents *********************************************/\n    struct Doc {\n        string docURI;\n        bytes32 docHash;\n    }\n    // Mapping for token URIs.\n    mapping(bytes32 => Doc) internal _documents;\n    /************************************************************************************************/\n\n    /*********************************** Partitions  mappings ***************************************/\n    // List of partitions.\n    bytes32[] internal _totalPartitions;\n\n    // Mapping from partition to their index.\n    mapping(bytes32 => uint256) internal _indexOfTotalPartitions;\n\n    // Mapping from partition to global balance of corresponding partition.\n    mapping(bytes32 => uint256) internal _totalSupplyByPartition;\n\n    // Mapping from tokenHolder to their partitions.\n    mapping(address => bytes32[]) internal _partitionsOf;\n\n    // Mapping from (tokenHolder, partition) to their index.\n    mapping(address => mapping(bytes32 => uint256))\n        internal _indexOfPartitionsOf;\n\n    // Mapping from (tokenHolder, partition) to balance of corresponding partition.\n    mapping(address => mapping(bytes32 => uint256))\n        internal _balanceOfByPartition;\n\n    // List of token default partitions (for ERC20 compatibility).\n    bytes32[] internal _defaultPartitions;\n    /************************************************************************************************/\n\n    /********************************* Global operators mappings ************************************/\n    // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\n    mapping(address => mapping(address => bool)) internal _authorizedOperator;\n\n    // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n    address[] internal _controllers;\n\n    // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n    mapping(address => bool) internal _isController;\n    /************************************************************************************************/\n\n    /******************************** Partition operators mappings **********************************/\n    // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\n    mapping(bytes32 => mapping(address => mapping(address => uint256)))\n        internal _allowedByPartition;\n\n    // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\n        internal _authorizedOperatorByPartition;\n\n    // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\n    mapping(bytes32 => address[]) internal _controllersByPartition;\n\n    // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\n    mapping(bytes32 => mapping(address => bool))\n        internal _isControllerByPartition;\n    /************************************************************************************************/\n\n    /***************************************** Modifiers ********************************************/\n    /**\n     * @dev Modifier to verify if token is issuable.\n     */\n    modifier isIssuableToken() {\n        require(_isIssuable, \"55\"); // 0x55\tfunds locked (lockup period)\n        _;\n    }\n    /**\n     * @dev Modifier to make a function callable only when the contract is not migrated.\n     */\n    modifier isNotMigratedToken() {\n        require(!_migrated, \"54\"); // 0x54\ttransfers halted (contract paused)\n        _;\n    }\n    /**\n     * @dev Modifier to verifiy if sender is a minter.\n     */\n    modifier onlyMinter() {\n        require(isMinter(msg.sender) || isOwner());\n        _;\n    }\n    /************************************************************************************************/\n\n    /**************************** Events (additional - not mandatory) *******************************/\n    event ApprovalByPartition(\n        bytes32 indexed partition,\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /************************************************************************************************/\n\n    /**\n     * @dev Initialize ERC1400 + register the contract implementation in ERC1820Registry.\n     * @param name Name of the token.\n     * @param symbol Symbol of the token.\n     * @param granularity Granularity of the token.\n     * @param controllers Array of initial controllers.\n     * @param defaultPartitions Partitions chosen by default, when partition is\n     * not specified, like the case ERC20 tranfers.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 granularity,\n        address[] memory controllers,\n        bytes32[] memory defaultPartitions\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _totalSupply = 0;\n        require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\n        _granularity = granularity;\n\n        _setControllers(controllers);\n\n        _defaultPartitions = defaultPartitions;\n\n        _isControllable = true;\n        _isIssuable = true;\n\n        // Register contract in ERC1820 registry\n        ERC1820Client.setInterfaceImplementation(\n            ERC1400_INTERFACE_NAME,\n            address(this)\n        );\n        ERC1820Client.setInterfaceImplementation(\n            ERC20_INTERFACE_NAME,\n            address(this)\n        );\n\n        // Indicate token verifies ERC1400 and ERC20 interfaces\n        ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\n        ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\n    }\n\n    /************************************************************************************************/\n    /****************************** EXTERNAL FUNCTIONS (ERC20 INTERFACE) ****************************/\n    /************************************************************************************************/\n\n    /**\n     * @dev Get the total number of issued tokens.\n     * @return Total supply of tokens currently in circulation.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Get the balance of the account with address 'tokenHolder'.\n     * @param tokenHolder Address for which the balance is returned.\n     * @return Amount of token held by 'tokenHolder' in the token contract.\n     */\n    function balanceOf(address tokenHolder) external view returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev Transfer token for a specified address.\n     * @param to The address to transfer to.\n     * @param value The value to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\");\n        return true;\n    }\n\n    /**\n     * @dev Check the value of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the value of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approve(address spender, uint256 value) external returns (bool) {\n        require(spender != address(0), \"56\"); // 0x56\tinvalid sender\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * @param from The address which you want to transfer tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        require(\n            _isOperator(msg.sender, from) ||\n                (value <= _allowed[from][msg.sender]),\n            \"53\"\n        ); // 0x53\tinsufficient allowance\n\n        if (_allowed[from][msg.sender] >= value) {\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        } else {\n            _allowed[from][msg.sender] = 0;\n        }\n\n        _transferByDefaultPartitions(msg.sender, from, to, value, \"\");\n        return true;\n    }\n\n    /************************************************************************************************/\n    /****************************** EXTERNAL FUNCTIONS (ERC1400 INTERFACE) **************************/\n    /************************************************************************************************/\n\n    /************************************* Document Management **************************************/\n    /**\n     * @dev Access a document associated with the token.\n     * @param name Short name (represented as a bytes32) associated to the document.\n     * @return Requested document + document hash.\n     */\n    function getDocument(bytes32 name)\n        external\n        view\n        returns (string memory, bytes32)\n    {\n        require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\n        return (_documents[name].docURI, _documents[name].docHash);\n    }\n\n    /**\n     * @dev Associate a document with the token.\n     * @param name Short name (represented as a bytes32) associated to the document.\n     * @param uri Document content.\n     * @param documentHash Hash of the document [optional parameter].\n     */\n    function setDocument(\n        bytes32 name,\n        string calldata uri,\n        bytes32 documentHash\n    ) external {\n        require(_isController[msg.sender]);\n        _documents[name] = Doc({docURI: uri, docHash: documentHash});\n        emit Document(name, uri, documentHash);\n    }\n\n    /************************************************************************************************/\n\n    /************************************** Token Information ***************************************/\n    /**\n     * @dev Get balance of a tokenholder for a specific partition.\n     * @param partition Name of the partition.\n     * @param tokenHolder Address for which the balance is returned.\n     * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\n     */\n    function balanceOfByPartition(bytes32 partition, address tokenHolder)\n        external\n        view\n        returns (uint256)\n    {\n        return _balanceOfByPartition[tokenHolder][partition];\n    }\n\n    /**\n     * @dev Get partitions index of a tokenholder.\n     * @param tokenHolder Address for which the partitions index are returned.\n     * @return Array of partitions index of 'tokenHolder'.\n     */\n    function partitionsOf(address tokenHolder)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return _partitionsOf[tokenHolder];\n    }\n\n    /************************************************************************************************/\n\n    /****************************************** Transfers *******************************************/\n    /**\n     * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer, by the token holder.\n     */\n    function transferWithData(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data);\n    }\n\n    /**\n     * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\n     * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer, and intended for the token holder ('from').\n     */\n    function transferFromWithData(\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        require(_isOperator(msg.sender, from), \"58\"); // 0x58\tinvalid operator (transfer agent)\n\n        _transferByDefaultPartitions(msg.sender, from, to, value, data);\n    }\n\n    /************************************************************************************************/\n\n    /********************************** Partition Token Transfers ***********************************/\n    /**\n     * @dev Transfer tokens from a specific partition.\n     * @param partition Name of the partition.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer, by the token holder.\n     * @return Destination partition.\n     */\n    function transferByPartition(\n        bytes32 partition,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes32) {\n        return\n            _transferByPartition(\n                partition,\n                msg.sender,\n                msg.sender,\n                to,\n                value,\n                data,\n                \"\"\n            );\n    }\n\n    /**\n     * @dev Transfer tokens from a specific partition through an operator.\n     * @param partition Name of the partition.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @param operatorData Information attached to the transfer, by the operator.\n     * @return Destination partition.\n     */\n    function operatorTransferByPartition(\n        bytes32 partition,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external returns (bytes32) {\n        require(\n            _isOperatorForPartition(partition, msg.sender, from) ||\n                (value <= _allowedByPartition[partition][from][msg.sender]),\n            \"53\"\n        ); // 0x53\tinsufficient allowance\n\n        if (_allowedByPartition[partition][from][msg.sender] >= value) {\n            _allowedByPartition[partition][from][\n                msg.sender\n            ] = _allowedByPartition[partition][from][msg.sender].sub(value);\n        } else {\n            _allowedByPartition[partition][from][msg.sender] = 0;\n        }\n\n        return\n            _transferByPartition(\n                partition,\n                msg.sender,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Controller Operation *************************************/\n    /**\n     * @dev Know if the token can be controlled by operators.\n     * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\n     * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\n     */\n    function isControllable() external view returns (bool) {\n        return _isControllable;\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Operator Management **************************************/\n    /**\n     * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\n     * and redeem tokens on its behalf.\n     * @param operator Address to set as an operator for 'msg.sender'.\n     */\n    function authorizeOperator(address operator) external {\n        require(operator != msg.sender);\n        _authorizedOperator[operator][msg.sender] = true;\n        emit AuthorizedOperator(operator, msg.sender);\n    }\n\n    /**\n     * @dev Remove the right of the operator address to be an operator for 'msg.sender'\n     * and to transfer and redeem tokens on its behalf.\n     * @param operator Address to rescind as an operator for 'msg.sender'.\n     */\n    function revokeOperator(address operator) external {\n        require(operator != msg.sender);\n        _authorizedOperator[operator][msg.sender] = false;\n        emit RevokedOperator(operator, msg.sender);\n    }\n\n    /**\n     * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\n     * @param partition Name of the partition.\n     * @param operator Address to set as an operator for 'msg.sender'.\n     */\n    function authorizeOperatorByPartition(bytes32 partition, address operator)\n        external\n    {\n        _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\n        emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\n    }\n\n    /**\n     * @dev Remove the right of the operator address to be an operator on a given\n     * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\n     * @param partition Name of the partition.\n     * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\n     */\n    function revokeOperatorByPartition(bytes32 partition, address operator)\n        external\n    {\n        _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\n        emit RevokedOperatorByPartition(partition, operator, msg.sender);\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Operator Information *************************************/\n    /**\n     * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n     * @param operator Address which may be an operator of tokenHolder.\n     * @param tokenHolder Address of a token holder which may have the operator address as an operator.\n     * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\n     */\n    function isOperator(address operator, address tokenHolder)\n        external\n        view\n        returns (bool)\n    {\n        return _isOperator(operator, tokenHolder);\n    }\n\n    /**\n     * @dev Indicate whether the operator address is an operator of the tokenHolder\n     * address for the given partition.\n     * @param partition Name of the partition.\n     * @param operator Address which may be an operator of tokenHolder for the given partition.\n     * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n     * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n     */\n    function isOperatorForPartition(\n        bytes32 partition,\n        address operator,\n        address tokenHolder\n    ) external view returns (bool) {\n        return _isOperatorForPartition(partition, operator, tokenHolder);\n    }\n\n    /************************************************************************************************/\n\n    /**************************************** Token Issuance ****************************************/\n    /**\n     * @dev Know if new tokens can be issued in the future.\n     * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\n     */\n    function isIssuable() external view returns (bool) {\n        return _isIssuable;\n    }\n\n    /**\n     * @dev Issue tokens from default partition.\n     * @param tokenHolder Address for which we want to issue tokens.\n     * @param value Number of tokens issued.\n     * @param data Information attached to the issuance, by the issuer.\n     */\n    function issue(\n        address tokenHolder,\n        uint256 value,\n        bytes calldata data\n    ) external onlyMinter isIssuableToken {\n        require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\n\n        _issueByPartition(\n            _defaultPartitions[0],\n            msg.sender,\n            tokenHolder,\n            value,\n            data\n        );\n    }\n\n    /**\n     * @dev Issue tokens from a specific partition.\n     * @param partition Name of the partition.\n     * @param tokenHolder Address for which we want to issue tokens.\n     * @param value Number of tokens issued.\n     * @param data Information attached to the issuance, by the issuer.\n     */\n    function issueByPartition(\n        bytes32 partition,\n        address tokenHolder,\n        uint256 value,\n        bytes calldata data\n    ) external onlyMinter isIssuableToken {\n        _issueByPartition(partition, msg.sender, tokenHolder, value, data);\n    }\n\n    /************************************************************************************************/\n\n    /*************************************** Token Redemption ***************************************/\n    /**\n     * @dev Redeem the amount of tokens from the address 'msg.sender'.\n     * @param value Number of tokens to redeem.\n     * @param data Information attached to the redemption, by the token holder.\n     */\n    function redeem(uint256 value, bytes calldata data) external {\n        _redeemByDefaultPartitions(msg.sender, msg.sender, value, data);\n    }\n\n    /**\n     * @dev Redeem the amount of tokens on behalf of the address from.\n     * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\n     * @param value Number of tokens to redeem.\n     * @param data Information attached to the redemption.\n     */\n    function redeemFrom(\n        address from,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        require(_isOperator(msg.sender, from), \"58\"); // 0x58\tinvalid operator (transfer agent)\n\n        _redeemByDefaultPartitions(msg.sender, from, value, data);\n    }\n\n    /**\n     * @dev Redeem tokens of a specific partition.\n     * @param partition Name of the partition.\n     * @param value Number of tokens redeemed.\n     * @param data Information attached to the redemption, by the redeemer.\n     */\n    function redeemByPartition(\n        bytes32 partition,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\n    }\n\n    /**\n     * @dev Redeem tokens of a specific partition.\n     * @param partition Name of the partition.\n     * @param tokenHolder Address for which we want to redeem tokens.\n     * @param value Number of tokens redeemed\n     * @param operatorData Information attached to the redemption, by the operator.\n     */\n    function operatorRedeemByPartition(\n        bytes32 partition,\n        address tokenHolder,\n        uint256 value,\n        bytes calldata operatorData\n    ) external {\n        require(\n            _isOperatorForPartition(partition, msg.sender, tokenHolder),\n            \"58\"\n        ); // 0x58\tinvalid operator (transfer agent)\n\n        _redeemByPartition(\n            partition,\n            msg.sender,\n            tokenHolder,\n            value,\n            \"\",\n            operatorData\n        );\n    }\n\n    /************************************************************************************************/\n\n    /************************************************************************************************/\n    /************************ EXTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\n    /************************************************************************************************/\n\n    /************************************ Token description *****************************************/\n    /**\n     * @dev Get the name of the token, e.g., \"MyToken\".\n     * @return Name of the token.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Get the symbol of the token, e.g., \"MYT\".\n     * @return Symbol of the token.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Get the number of decimals of the token.\n     * @return The number of decimals of the token. For retrocompatibility, decimals are forced to 18 in ERC1400.\n     */\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    /**\n     * @dev Get the smallest part of the token that’s not divisible.\n     * @return The smallest non-divisible part of the token.\n     */\n    function granularity() external view returns (uint256) {\n        return _granularity;\n    }\n\n    /**\n     * @dev Get list of existing partitions.\n     * @return Array of all exisiting partitions.\n     */\n    function totalPartitions() external view returns (bytes32[] memory) {\n        return _totalPartitions;\n    }\n\n    /**\n     * @dev Get the total number of issued tokens for a given partition.\n     * @param partition Name of the partition.\n     * @return Total supply of tokens currently in circulation, for a given partition.\n     */\n    function totalSupplyByPartition(bytes32 partition)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalSupplyByPartition[partition];\n    }\n\n    /************************************************************************************************/\n\n    /**************************************** Token behaviours **************************************/\n    /**\n     * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\n     * Once set to false, '_isControllable' can never be set to 'true' again.\n     */\n    function renounceControl() external onlyOwner {\n        _isControllable = false;\n    }\n\n    /**\n     * @dev Definitely renounce the possibility to issue new tokens.\n     * Once set to false, '_isIssuable' can never be set to 'true' again.\n     */\n    function renounceIssuance() external onlyOwner {\n        _isIssuable = false;\n    }\n\n    /************************************************************************************************/\n\n    /************************************ Token controllers *****************************************/\n    /**\n     * @dev Get the list of controllers as defined by the token contract.\n     * @return List of addresses of all the controllers.\n     */\n    function controllers() external view returns (address[] memory) {\n        return _controllers;\n    }\n\n    /**\n     * @dev Get controllers for a given partition.\n     * @param partition Name of the partition.\n     * @return Array of controllers for partition.\n     */\n    function controllersByPartition(bytes32 partition)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _controllersByPartition[partition];\n    }\n\n    /**\n     * @dev Set list of token controllers.\n     * @param operators Controller addresses.\n     */\n    function setControllers(address[] calldata operators) external onlyOwner {\n        _setControllers(operators);\n    }\n\n    /**\n     * @dev Set list of token partition controllers.\n     * @param partition Name of the partition.\n     * @param operators Controller addresses.\n     */\n    function setPartitionControllers(\n        bytes32 partition,\n        address[] calldata operators\n    ) external onlyOwner {\n        _setPartitionControllers(partition, operators);\n    }\n\n    /************************************************************************************************/\n\n    /********************************* Token default partitions *************************************/\n    /**\n     * @dev Get default partitions to transfer from.\n     * Function used for ERC20 retrocompatibility.\n     * For example, a security token may return the bytes32(\"unrestricted\").\n     * @return Array of default partitions.\n     */\n    function getDefaultPartitions() external view returns (bytes32[] memory) {\n        return _defaultPartitions;\n    }\n\n    /**\n     * @dev Set default partitions to transfer from.\n     * Function used for ERC20 retrocompatibility.\n     * @param partitions partitions to use by default when not specified.\n     */\n    function setDefaultPartitions(bytes32[] calldata partitions)\n        external\n        onlyOwner\n    {\n        _defaultPartitions = partitions;\n    }\n\n    /************************************************************************************************/\n\n    /******************************** Partition Token Allowances ************************************/\n    /**\n     * @dev Check the value of tokens that an owner allowed to a spender.\n     * @param partition Name of the partition.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the value of tokens still available for the spender.\n     */\n    function allowanceByPartition(\n        bytes32 partition,\n        address owner,\n        address spender\n    ) external view returns (uint256) {\n        return _allowedByPartition[partition][owner][spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\n     * @param partition Name of the partition.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approveByPartition(\n        bytes32 partition,\n        address spender,\n        uint256 value\n    ) external returns (bool) {\n        require(spender != address(0), \"56\"); // 0x56\tinvalid sender\n        _allowedByPartition[partition][msg.sender][spender] = value;\n        emit ApprovalByPartition(partition, msg.sender, spender, value);\n        return true;\n    }\n\n    /************************************************************************************************/\n\n    /************************************** Token extension *****************************************/\n    /**\n     * @dev Set token extension contract address.\n     * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\n     * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\n     * @param extension Address of the extension contract.\n     * @param interfaceLabel Interface label of extension contract.\n     * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\n     * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\n     * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\n     */\n    function setTokenExtension(\n        address extension,\n        string calldata interfaceLabel,\n        bool removeOldExtensionRoles,\n        bool addMinterRoleForExtension,\n        bool addControllerRoleForExtension\n    ) external onlyOwner {\n        _setTokenExtension(\n            extension,\n            interfaceLabel,\n            removeOldExtensionRoles,\n            addMinterRoleForExtension,\n            addControllerRoleForExtension\n        );\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Token migration ******************************************/\n    /**\n     * @dev Migrate contract.\n     *\n     * ===> CAUTION: DEFINITIVE ACTION\n     *\n     * This function shall be called once a new version of the smart contract has been created.\n     * Once this function is called:\n     *  - The address of the new smart contract is set in ERC1820 registry\n     *  - If the choice is definitive, the current smart contract is turned off and can never be used again\n     *\n     * @param newContractAddress Address of the new version of the smart contract.\n     * @param definitive If set to 'true' the contract is turned off definitely.\n     */\n    function migrate(address newContractAddress, bool definitive)\n        external\n        onlyOwner\n    {\n        _migrate(newContractAddress, definitive);\n    }\n\n    /************************************************************************************************/\n\n    /************************************************************************************************/\n    /************************************* INTERNAL FUNCTIONS ***************************************/\n    /************************************************************************************************/\n\n    /**************************************** Token Transfers ***************************************/\n    /**\n     * @dev Perform the transfer of tokens.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     */\n    function _transferWithData(\n        address from,\n        address to,\n        uint256 value\n    ) internal isNotMigratedToken {\n        require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n        require(to != address(0), \"57\"); // 0x57\tinvalid receiver\n        require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(from, to, value); // ERC20 retrocompatibility\n    }\n\n    /**\n     * @dev Transfer tokens from a specific partition.\n     * @param fromPartition Partition of the tokens to transfer.\n     * @param operator The address performing the transfer.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @param operatorData Information attached to the transfer, by the operator (if any).\n     * @return Destination partition.\n     */\n    function _transferByPartition(\n        bytes32 fromPartition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal returns (bytes32) {\n        require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\n\n        bytes32 toPartition = fromPartition;\n\n        if (operatorData.length != 0 && data.length >= 64) {\n            toPartition = _getDestinationPartition(fromPartition, data);\n        }\n\n        _callSenderExtension(\n            fromPartition,\n            operator,\n            from,\n            to,\n            value,\n            data,\n            operatorData\n        );\n        _callTokenExtension(\n            fromPartition,\n            operator,\n            from,\n            to,\n            value,\n            data,\n            operatorData\n        );\n\n        _removeTokenFromPartition(from, fromPartition, value);\n        _transferWithData(from, to, value);\n        _addTokenToPartition(to, toPartition, value);\n\n        _callRecipientExtension(\n            toPartition,\n            operator,\n            from,\n            to,\n            value,\n            data,\n            operatorData\n        );\n\n        emit TransferByPartition(\n            fromPartition,\n            operator,\n            from,\n            to,\n            value,\n            data,\n            operatorData\n        );\n\n        if (toPartition != fromPartition) {\n            emit ChangedPartition(fromPartition, toPartition, value);\n        }\n\n        return toPartition;\n    }\n\n    /**\n     * @dev Transfer tokens from default partitions.\n     * Function used for ERC20 retrocompatibility.\n     * @param operator The address performing the transfer.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\n     */\n    function _transferByDefaultPartitions(\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        require(_defaultPartitions.length != 0, \"55\"); // // 0x55\tfunds locked (lockup period)\n\n        uint256 _remainingValue = value;\n        uint256 _localBalance;\n\n        for (uint256 i = 0; i < _defaultPartitions.length; i++) {\n            _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n            if (_remainingValue <= _localBalance) {\n                _transferByPartition(\n                    _defaultPartitions[i],\n                    operator,\n                    from,\n                    to,\n                    _remainingValue,\n                    data,\n                    \"\"\n                );\n                _remainingValue = 0;\n                break;\n            } else if (_localBalance != 0) {\n                _transferByPartition(\n                    _defaultPartitions[i],\n                    operator,\n                    from,\n                    to,\n                    _localBalance,\n                    data,\n                    \"\"\n                );\n                _remainingValue = _remainingValue - _localBalance;\n            }\n        }\n\n        require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\n    }\n\n    /**\n     * @dev Retrieve the destination partition from the 'data' field.\n     * By convention, a partition change is requested ONLY when 'data' starts\n     * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n     * When the flag is detected, the destination tranche is extracted from the\n     * 32 bytes following the flag.\n     * @param fromPartition Partition of the tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @return Destination partition.\n     */\n    function _getDestinationPartition(bytes32 fromPartition, bytes memory data)\n        internal\n        pure\n        returns (bytes32 toPartition)\n    {\n        bytes32 changePartitionFlag =\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        bytes32 flag;\n        assembly {\n            flag := mload(add(data, 32))\n        }\n        if (flag == changePartitionFlag) {\n            assembly {\n                toPartition := mload(add(data, 64))\n            }\n        } else {\n            toPartition = fromPartition;\n        }\n    }\n\n    /**\n     * @dev Remove a token from a specific partition.\n     * @param from Token holder.\n     * @param partition Name of the partition.\n     * @param value Number of tokens to transfer.\n     */\n    function _removeTokenFromPartition(\n        address from,\n        bytes32 partition,\n        uint256 value\n    ) internal {\n        _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][\n            partition\n        ]\n            .sub(value);\n        _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition]\n            .sub(value);\n\n        // If the total supply is zero, finds and deletes the partition.\n        if (_totalSupplyByPartition[partition] == 0) {\n            uint256 index1 = _indexOfTotalPartitions[partition];\n            require(index1 > 0, \"50\"); // 0x50\ttransfer failure\n\n            // move the last item into the index being vacated\n            bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\n            _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\n            _indexOfTotalPartitions[lastValue] = index1;\n\n            _totalPartitions.length -= 1;\n            _indexOfTotalPartitions[partition] = 0;\n        }\n\n        // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\n        if (_balanceOfByPartition[from][partition] == 0) {\n            uint256 index2 = _indexOfPartitionsOf[from][partition];\n            require(index2 > 0, \"50\"); // 0x50\ttransfer failure\n\n            // move the last item into the index being vacated\n            bytes32 lastValue =\n                _partitionsOf[from][_partitionsOf[from].length - 1];\n            _partitionsOf[from][index2 - 1] = lastValue; // adjust for 1-based indexing\n            _indexOfPartitionsOf[from][lastValue] = index2;\n\n            _partitionsOf[from].length -= 1;\n            _indexOfPartitionsOf[from][partition] = 0;\n        }\n    }\n\n    /**\n     * @dev Add a token to a specific partition.\n     * @param to Token recipient.\n     * @param partition Name of the partition.\n     * @param value Number of tokens to transfer.\n     */\n    function _addTokenToPartition(\n        address to,\n        bytes32 partition,\n        uint256 value\n    ) internal {\n        if (value != 0) {\n            if (_indexOfPartitionsOf[to][partition] == 0) {\n                _partitionsOf[to].push(partition);\n                _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\n            }\n            _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][\n                partition\n            ]\n                .add(value);\n\n            if (_indexOfTotalPartitions[partition] == 0) {\n                _totalPartitions.push(partition);\n                _indexOfTotalPartitions[partition] = _totalPartitions.length;\n            }\n            _totalSupplyByPartition[partition] = _totalSupplyByPartition[\n                partition\n            ]\n                .add(value);\n        }\n    }\n\n    /**\n     * @dev Check if 'value' is multiple of the granularity.\n     * @param value The quantity that want's to be checked.\n     * @return 'true' if 'value' is a multiple of the granularity.\n     */\n    function _isMultiple(uint256 value) internal view returns (bool) {\n        return (value.div(_granularity).mul(_granularity) == value);\n    }\n\n    /************************************************************************************************/\n\n    /****************************************** Hooks ***********************************************/\n    /**\n     * @dev Check for 'ERC1400TokensSender' user extension in ERC1820 registry and call it.\n     * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     */\n    function _callSenderExtension(\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal {\n        address senderImplementation;\n        senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\n        if (senderImplementation != address(0)) {\n            IERC1400TokensSender(senderImplementation).tokensToTransfer(\n                msg.data,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n        }\n    }\n\n    /**\n     * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\n     * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     */\n    function _callTokenExtension(\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal {\n        address validatorImplementation;\n        validatorImplementation = interfaceAddr(\n            address(this),\n            ERC1400_TOKENS_VALIDATOR\n        );\n        if (validatorImplementation != address(0)) {\n            IERC1400TokensValidator(validatorImplementation).tokensToValidate(\n                msg.data,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n        }\n    }\n\n    /**\n     * @dev Check for 'ERC1400TokensRecipient' user extension in ERC1820 registry and call it.\n     * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\n     * @param operator Address which triggered the balance increase (through transfer or issuance).\n     * @param from Token holder for a transfer and 0x for an issuance.\n     * @param to Token recipient.\n     * @param value Number of tokens the recipient balance is increased by.\n     * @param data Extra information, intended for the token holder ('from').\n     * @param operatorData Extra information attached by the operator (if any).\n     */\n    function _callRecipientExtension(\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal {\n        address recipientImplementation;\n        recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\n\n        if (recipientImplementation != address(0)) {\n            IERC1400TokensRecipient(recipientImplementation).tokensReceived(\n                msg.data,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n        }\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Operator Information *************************************/\n    /**\n     * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n     * @param operator Address which may be an operator of 'tokenHolder'.\n     * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\n     * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\n     */\n    function _isOperator(address operator, address tokenHolder)\n        internal\n        view\n        returns (bool)\n    {\n        return (operator == tokenHolder ||\n            _authorizedOperator[operator][tokenHolder] ||\n            (_isControllable && _isController[operator]));\n    }\n\n    /**\n     * @dev Indicate whether the operator address is an operator of the tokenHolder\n     * address for the given partition.\n     * @param partition Name of the partition.\n     * @param operator Address which may be an operator of tokenHolder for the given partition.\n     * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n     * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n     */\n    function _isOperatorForPartition(\n        bytes32 partition,\n        address operator,\n        address tokenHolder\n    ) internal view returns (bool) {\n        return (_isOperator(operator, tokenHolder) ||\n            _authorizedOperatorByPartition[tokenHolder][partition][operator] ||\n            (_isControllable && _isControllerByPartition[partition][operator]));\n    }\n\n    /************************************************************************************************/\n\n    /**************************************** Token Issuance ****************************************/\n    /**\n     * @dev Perform the issuance of tokens.\n     * @param operator Address which triggered the issuance.\n     * @param to Token recipient.\n     * @param value Number of tokens issued.\n     * @param data Information attached to the issuance, and intended for the recipient (to).\n     */\n    function _issue(\n        address operator,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal isNotMigratedToken {\n        require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n        require(to != address(0), \"57\"); // 0x57\tinvalid receiver\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[to] = _balances[to].add(value);\n\n        emit Issued(operator, to, value, data);\n        emit Transfer(address(0), to, value); // ERC20 retrocompatibility\n    }\n\n    /**\n     * @dev Issue tokens from a specific partition.\n     * @param toPartition Name of the partition.\n     * @param operator The address performing the issuance.\n     * @param to Token recipient.\n     * @param value Number of tokens to issue.\n     * @param data Information attached to the issuance.\n     */\n    function _issueByPartition(\n        bytes32 toPartition,\n        address operator,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        _callTokenExtension(\n            toPartition,\n            operator,\n            address(0),\n            to,\n            value,\n            data,\n            \"\"\n        );\n\n        _issue(operator, to, value, data);\n        _addTokenToPartition(to, toPartition, value);\n\n        _callRecipientExtension(\n            toPartition,\n            operator,\n            address(0),\n            to,\n            value,\n            data,\n            \"\"\n        );\n\n        emit IssuedByPartition(toPartition, operator, to, value, data, \"\");\n    }\n\n    /************************************************************************************************/\n\n    /*************************************** Token Redemption ***************************************/\n    /**\n     * @dev Perform the token redemption.\n     * @param operator The address performing the redemption.\n     * @param from Token holder whose tokens will be redeemed.\n     * @param value Number of tokens to redeem.\n     * @param data Information attached to the redemption.\n     */\n    function _redeem(\n        address operator,\n        address from,\n        uint256 value,\n        bytes memory data\n    ) internal isNotMigratedToken {\n        require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\n        require(from != address(0), \"56\"); // 0x56\tinvalid sender\n        require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\n\n        _balances[from] = _balances[from].sub(value);\n        _totalSupply = _totalSupply.sub(value);\n\n        emit Redeemed(operator, from, value, data);\n        emit Transfer(from, address(0), value); // ERC20 retrocompatibility\n    }\n\n    /**\n     * @dev Redeem tokens of a specific partition.\n     * @param fromPartition Name of the partition.\n     * @param operator The address performing the redemption.\n     * @param from Token holder whose tokens will be redeemed.\n     * @param value Number of tokens to redeem.\n     * @param data Information attached to the redemption.\n     * @param operatorData Information attached to the redemption, by the operator (if any).\n     */\n    function _redeemByPartition(\n        bytes32 fromPartition,\n        address operator,\n        address from,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal {\n        require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\n\n        _callSenderExtension(\n            fromPartition,\n            operator,\n            from,\n            address(0),\n            value,\n            data,\n            operatorData\n        );\n        _callTokenExtension(\n            fromPartition,\n            operator,\n            from,\n            address(0),\n            value,\n            data,\n            operatorData\n        );\n\n        _removeTokenFromPartition(from, fromPartition, value);\n        _redeem(operator, from, value, data);\n\n        emit RedeemedByPartition(\n            fromPartition,\n            operator,\n            from,\n            value,\n            operatorData\n        );\n    }\n\n    /**\n     * @dev Redeem tokens from a default partitions.\n     * @param operator The address performing the redeem.\n     * @param from Token holder.\n     * @param value Number of tokens to redeem.\n     * @param data Information attached to the redemption.\n     */\n    function _redeemByDefaultPartitions(\n        address operator,\n        address from,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\n\n        uint256 _remainingValue = value;\n        uint256 _localBalance;\n\n        for (uint256 i = 0; i < _defaultPartitions.length; i++) {\n            _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n            if (_remainingValue <= _localBalance) {\n                _redeemByPartition(\n                    _defaultPartitions[i],\n                    operator,\n                    from,\n                    _remainingValue,\n                    data,\n                    \"\"\n                );\n                _remainingValue = 0;\n                break;\n            } else {\n                _redeemByPartition(\n                    _defaultPartitions[i],\n                    operator,\n                    from,\n                    _localBalance,\n                    data,\n                    \"\"\n                );\n                _remainingValue = _remainingValue - _localBalance;\n            }\n        }\n\n        require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\n    }\n\n    /************************************************************************************************/\n\n    /************************************** Transfer Validity ***************************************/\n    /**\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition.\n     * @param operator The address performing the transfer.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @param operatorData Information attached to the transfer, by the operator (if any).\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n     * @return Additional bytes32 parameter that can be used to define\n     * application specific reason codes with additional details (for example the\n     * transfer restriction rule responsible for making the transfer operation invalid).\n     * @return Destination partition.\n     */\n    function _canTransfer(\n        bytes memory payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        view\n        returns (\n            bytes1,\n            bytes32,\n            bytes32\n        )\n    {\n        address checksImplementation =\n            interfaceAddr(address(this), ERC1400_TOKENS_CHECKER);\n\n        if ((checksImplementation != address(0))) {\n            return\n                IERC1400TokensChecker(checksImplementation)\n                    .canTransferByPartition(\n                    payload,\n                    partition,\n                    operator,\n                    from,\n                    to,\n                    value,\n                    data,\n                    operatorData\n                );\n        } else {\n            return (hex\"00\", \"\", partition);\n        }\n    }\n\n    /************************************************************************************************/\n\n    /************************************************************************************************/\n    /************************ INTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\n    /************************************************************************************************/\n\n    /************************************ Token controllers *****************************************/\n    /**\n     * @dev Set list of token controllers.\n     * @param operators Controller addresses.\n     */\n    function _setControllers(address[] memory operators) internal {\n        for (uint256 i = 0; i < _controllers.length; i++) {\n            _isController[_controllers[i]] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isController[operators[j]] = true;\n        }\n        _controllers = operators;\n    }\n\n    /**\n     * @dev Set list of token partition controllers.\n     * @param partition Name of the partition.\n     * @param operators Controller addresses.\n     */\n    function _setPartitionControllers(\n        bytes32 partition,\n        address[] memory operators\n    ) internal {\n        for (\n            uint256 i = 0;\n            i < _controllersByPartition[partition].length;\n            i++\n        ) {\n            _isControllerByPartition[partition][\n                _controllersByPartition[partition][i]\n            ] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isControllerByPartition[partition][operators[j]] = true;\n        }\n        _controllersByPartition[partition] = operators;\n    }\n\n    /************************************************************************************************/\n\n    /************************************** Token extension *****************************************/\n    /**\n     * @dev Set token extension contract address.\n     * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\n     * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\n     * @param extension Address of the extension contract.\n     * @param interfaceLabel Interface label of extension contract.\n     * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\n     * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\n     * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\n     */\n    function _setTokenExtension(\n        address extension,\n        string memory interfaceLabel,\n        bool removeOldExtensionRoles,\n        bool addMinterRoleForExtension,\n        bool addControllerRoleForExtension\n    ) internal {\n        address oldExtension = interfaceAddr(address(this), interfaceLabel);\n\n        if (oldExtension != address(0) && removeOldExtensionRoles) {\n            if (isMinter(oldExtension)) {\n                _removeMinter(oldExtension);\n            }\n            _isController[oldExtension] = false;\n        }\n\n        ERC1820Client.setInterfaceImplementation(interfaceLabel, extension);\n        if (addMinterRoleForExtension && !isMinter(extension)) {\n            _addMinter(extension);\n        }\n        if (addControllerRoleForExtension) {\n            _isController[extension] = true;\n        }\n    }\n\n    /************************************************************************************************/\n\n    /************************************* Token migration ******************************************/\n    /**\n     * @dev Migrate contract.\n     *\n     * ===> CAUTION: DEFINITIVE ACTION\n     *\n     * This function shall be called once a new version of the smart contract has been created.\n     * Once this function is called:\n     *  - The address of the new smart contract is set in ERC1820 registry\n     *  - If the choice is definitive, the current smart contract is turned off and can never be used again\n     *\n     * @param newContractAddress Address of the new version of the smart contract.\n     * @param definitive If set to 'true' the contract is turned off definitely.\n     */\n    function _migrate(address newContractAddress, bool definitive) internal {\n        ERC1820Client.setInterfaceImplementation(\n            ERC20_INTERFACE_NAME,\n            newContractAddress\n        );\n        ERC1820Client.setInterfaceImplementation(\n            ERC1400_INTERFACE_NAME,\n            newContractAddress\n        );\n        if (definitive) {\n            _migrated = true;\n        }\n    }\n    /************************************************************************************************/\n}\n"
    },
    "contracts/capTable/CapTableRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./Controllable.sol\";\n\ncontract CapTableRegistry is Controllable {\n    address[] internal _capTables;\n    mapping(address => uint256) internal _status; // 0:notUsed 1:qued 2:approved 3:declined 4:removed\n    mapping(address => bytes32) internal _addressToUuid;\n    mapping(bytes32 => address) internal _uuidToAddress;\n    mapping(bytes32 => address) internal _uuidToQuedAddress;\n    uint256 internal _activeCapTables;\n    uint256 internal _quedCapTables;\n\n    event capTableQued(address indexed capTableAddress, bytes32 indexed uuid);\n    event capTableApproved(address indexed capTableAddress);\n    event capTableRemoved(address indexed capTableAddress);\n    event capTableDeclined(address indexed capTableAddress, bytes32 reason);\n\n    constructor(address[] memory controllers)\n        public\n        Controllable(controllers)\n    {}\n\n    function que(address adr, bytes32 uuid) external {\n        _queCapTable(adr, uuid);\n    }\n\n    function approve(address adr) external {\n        _approveCapTable(adr);\n    }\n\n    function decline(address adr, bytes32 reason) external {\n        _declineCapTable(adr, reason);\n    }\n\n    function remove(address adr) external {\n        _removeCapTable(adr);\n    }\n\n    function getActiveCount() external view returns (uint256 activeCapTables) {\n        return _activeCapTables;\n    }\n\n    function getQuedCount() external view returns (uint256 quedCapTables) {\n        return _quedCapTables;\n    }\n\n    function getList() external view returns (address[] memory capTableList) {\n        return _capTables;\n    }\n\n    function getUuid(address adr) external view returns (bytes32 uuid) {\n        return _addressToUuid[adr];\n    }\n\n    function getStatus(address adr) external view returns (uint256 status) {\n        return _status[adr];\n    }\n\n    function getAddress(bytes32 uuid)\n        external\n        view\n        returns (address capTableAddress)\n    {\n        return _uuidToAddress[uuid];\n    }\n\n    // REVIEW : Only a helper function to retreive last qued address for an UUID. Somone can easily overwrite this, so its not safe. Can lead to confusion it result is not properly checked.\n    function getLastQuedAddress(bytes32 uuid)\n        external\n        view\n        returns (address capTableAddress)\n    {\n        return _uuidToQuedAddress[uuid];\n    }\n\n    function info(address adr)\n        external\n        view\n        returns (bytes32 uuid, uint256 active)\n    {\n        return (_addressToUuid[adr], _status[adr]);\n    }\n\n    function _queCapTable(address adr, bytes32 uuid) internal {\n        require(\n            _status[adr] != 1,\n            \"Qued capTables must be declined before reQue\"\n        );\n        require(_status[adr] != 2, \"Cannot que active capTable\");\n        _capTables.push(adr);\n        _status[adr] = 1;\n        _addressToUuid[adr] = uuid;\n        _uuidToQuedAddress[uuid] = adr;\n        _quedCapTables++;\n        emit capTableQued(adr, uuid);\n    }\n\n    function _approveCapTable(address adr) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be approved\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 2;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToAddress[uuid] = adr;\n        _uuidToQuedAddress[uuid] = address(0);\n        _quedCapTables--;\n        _activeCapTables++;\n        emit capTableApproved(adr);\n    }\n\n    function _declineCapTable(address adr, bytes32 reason) internal {\n        require(_status[adr] == 1, \"Only qued capTables can be declined\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 3;\n        _quedCapTables--;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToQuedAddress[uuid] = address(0);\n        emit capTableDeclined(adr, reason);\n    }\n\n    function _removeCapTable(address adr) internal {\n        require(_status[adr] == 2, \"Only approved capTables can be removed\");\n        require(isController(msg.sender), \"msg.sender is not controller\");\n        _status[adr] = 4;\n        bytes32 uuid = _addressToUuid[adr];\n        _uuidToAddress[uuid] = address(0);\n        _activeCapTables--;\n        emit capTableRemoved(adr);\n    }\n}\n"
    },
    "contracts/capTable/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ncontract Controllable {\n    address[] internal _controllers;\n    mapping(address => bool) internal _isController;\n\n    constructor(address[] memory controllers) public {\n        _setControllers(controllers);\n    }\n\n    function controllers() external view returns (address[] memory) {\n        return _controllers;\n    }\n\n    function setControllers(address[] calldata operators) external {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        _setControllers(operators);\n    }\n\n    function isController(address adr) public view returns (bool) {\n        return _isController[adr];\n    }\n\n    function _setControllers(address[] memory adresses) internal {\n        for (uint256 i = 0; i < _controllers.length; i++) {\n            _isController[_controllers[i]] = false;\n        }\n        for (uint256 j = 0; j < adresses.length; j++) {\n            _isController[adresses[j]] = true;\n        }\n        _controllers = adresses;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/ERC1820/ERC1820Client.sol": {
      "content": "pragma solidity ^0.5.3;\n\ncontract IERC1820Registry {\n    function setInterfaceImplementer(\n        address _addr,\n        bytes32 _interfaceHash,\n        address _implementer\n    ) external;\n\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\n        external\n        view\n        returns (address);\n\n    function setManager(address _addr, address _newManager) external;\n\n    function getManager(address _addr) public view returns (address);\n}\n\n/// Base client to interact with the registry.\ncontract ERC1820Client {\n    IERC1820Registry constant ERC1820REGISTRY =\n        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    function setInterfaceImplementation(\n        string memory _interfaceLabel,\n        address _implementation\n    ) internal {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        ERC1820REGISTRY.setInterfaceImplementer(\n            address(this),\n            interfaceHash,\n            _implementation\n        );\n    }\n\n    function interfaceAddr(address addr, string memory _interfaceLabel)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        ERC1820REGISTRY.setManager(address(this), _newManager);\n    }\n}\n"
    },
    "contracts/interface/ERC1820Implementer.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n\ncontract ERC1820Implementer {\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n  mapping(bytes32 => bool) internal _interfaceHashes;\n\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n    external\n    view\n    returns(bytes32)\n  {\n    if(_interfaceHashes[interfaceHash]) {\n      return ERC1820_ACCEPT_MAGIC;\n    } else {\n      return \"\";\n    }\n  }\n\n  function _setInterface(string memory interfaceLabel) internal {\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n  }\n\n}\n"
    },
    "contracts/roles/MinterRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\n/**\n * @title MinterRole\n * @dev Minters are responsible for minting new tokens.\n */\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function removeMinter(address account) public onlyMinter {\n        _removeMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}"
    },
    "contracts/IERC1400.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title IERC1400 security token standard\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\n */\ninterface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\n\n  // ****************** Document Management *******************\n  function getDocument(bytes32 name) external view returns (string memory, bytes32);\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n\n  // ******************* Token Information ********************\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\n\n  // *********************** Transfers ************************\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\n\n  // *************** Partition Token Transfers ****************\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n\n  // ****************** Controller Operation ******************\n  function isControllable() external view returns (bool);\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\n\n  // ****************** Operator Management *******************\n  function authorizeOperator(address operator) external;\n  function revokeOperator(address operator) external;\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\n\n  // ****************** Operator Information ******************\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\n\n  // ********************* Token Issuance *********************\n  function isIssuable() external view returns (bool);\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\n\n  // ******************** Token Redemption ********************\n  function redeem(uint256 value, bytes calldata data) external;\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\n\n  // ******************* Transfer Validity ********************\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\n  //\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \n\n  // ******************* Controller Events ********************\n  // We don't use this event as we don't use \"controllerTransfer\"\n  //   event ControllerTransfer(\n  //       address controller,\n  //       address indexed from,\n  //       address indexed to,\n  //       uint256 value,\n  //       bytes data,\n  //       bytes operatorData\n  //   );\n  //\n  // We don't use this event as we don't use \"controllerRedeem\"\n  //   event ControllerRedemption(\n  //       address controller,\n  //       address indexed tokenHolder,\n  //       uint256 value,\n  //       bytes data,\n  //       bytes operatorData\n  //   );\n\n  // ******************** Document Events *********************\n  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\n\n  // ******************** Transfer Events *********************\n  event TransferByPartition(\n      bytes32 indexed fromPartition,\n      address operator,\n      address indexed from,\n      address indexed to,\n      uint256 value,\n      bytes data,\n      bytes operatorData\n  );\n\n  event ChangedPartition(\n      bytes32 indexed fromPartition,\n      bytes32 indexed toPartition,\n      uint256 value\n  );\n\n  // ******************** Operator Events *********************\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n  // ************** Issuance / Redemption Events **************\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\n\n}\n\n/**\n * Reason codes - ERC-1066\n *\n * To improve the token holder experience, canTransfer MUST return a reason byte code\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\n * An implementation can also return arbitrary data as a bytes32 to provide additional\n * information not captured by the reason code.\n * \n * Code\tReason\n * 0x50\ttransfer failure\n * 0x51\ttransfer success\n * 0x52\tinsufficient balance\n * 0x53\tinsufficient allowance\n * 0x54\ttransfers halted (contract paused)\n * 0x55\tfunds locked (lockup period)\n * 0x56\tinvalid sender\n * 0x57\tinvalid receiver\n * 0x58\tinvalid operator (transfer agent)\n * 0x59\t\n * 0x5a\t\n * 0x5b\t\n * 0x5a\t\n * 0x5b\t\n * 0x5c\t\n * 0x5d\t\n * 0x5e\t\n * 0x5f\ttoken meta or info\n *\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\n */"
    },
    "contracts/extensions/tokenExtensions/IERC1400TokensValidator.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title IERC1400TokensValidator\n * @dev ERC1400TokensValidator interface\n */\ninterface IERC1400TokensValidator {\n\n  function canValidate(\n    address token,\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensToValidate(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "contracts/extensions/tokenExtensions/IERC1400TokensChecker.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title IERC1400TokensChecker\n * @dev IERC1400TokensChecker interface\n */\ninterface IERC1400TokensChecker {\n\n  // function canTransfer(\n  //   bytes calldata payload,\n  //   address operator,\n  //   address from,\n  //   address to,\n  //   uint256 value,\n  //   bytes calldata data,\n  //   bytes calldata operatorData\n  // ) external view returns (byte, bytes32);\n\n  function canTransferByPartition(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes calldata data,\n    bytes calldata operatorData\n    ) external view returns (byte, bytes32, bytes32);\n\n}\n"
    },
    "contracts/extensions/userExtensions/IERC1400TokensSender.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title IERC1400TokensSender\n * @dev ERC1400TokensSender interface\n */\ninterface IERC1400TokensSender {\n\n  function canTransfer(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensToTransfer(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "contracts/extensions/userExtensions/IERC1400TokensRecipient.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title IERC1400TokensRecipient\n * @dev ERC1400TokensRecipient interface\n */\ninterface IERC1400TokensRecipient {\n\n  function canReceive(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensReceived(\n    bytes calldata payload,\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/tools/FundIssuer.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\n\nimport \"../ERC1820/ERC1820Client.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"../ERC1400.sol\";\n\n/**\n ***************************************************************************************************************\n **************************************** CAUTION: work in progress ********************************************\n ***************************************************************************************************************\n *\n * CAUTION: This contract is a work in progress, tests are not finalized yet!\n *\n ***************************************************************************************************************\n **************************************** CAUTION: work in progress ********************************************\n ***************************************************************************************************************\n */\n\n/**\n * @title FundIssuer\n * @dev Fund issuance contract.\n * @dev Intended usage:\n * The purpose of the contract is to perform a fund issuance.\n *\n */\ncontract FundIssuer is\n    ERC1820Client,\n    IERC1400TokensRecipient,\n    ERC1820Implementer\n{\n    using SafeMath for uint256;\n\n    bytes32\n        internal constant ORDER_SUBSCRIPTION_FLAG = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n    bytes32\n        internal constant ORDER_PAYMENT_FLAG = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\n\n    bytes32\n        internal constant BYPASS_ACTION_FLAG = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n\n    string internal constant FUND_ISSUER = \"FundIssuer\";\n    string\n        internal constant ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n    bytes32 internal constant ERC1820_ACCEPT_MAGIC = keccak256(\n        abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")\n    );\n\n    enum CycleState {\n        Undefined,\n        Subscription,\n        Valuation,\n        Payment,\n        Settlement,\n        Finalized\n    }\n\n    enum OrderState {\n        Undefined,\n        Subscribed,\n        Paid,\n        PaidSettled,\n        UnpaidSettled,\n        Cancelled,\n        Rejected\n    }\n\n    enum OrderType {Undefined, Value, Amount}\n\n    enum Payment {OffChain, ETH, ERC20, ERC1400}\n\n    enum AssetValue {Unknown, Known}\n\n    struct AssetRules {\n        bool defined;\n        uint256 firstStartTime;\n        uint256 subscriptionPeriodLength;\n        uint256 valuationPeriodLength;\n        uint256 paymentPeriodLength;\n        AssetValue assetValueType;\n        uint256 assetValue;\n        uint256 reverseAssetValue;\n        Payment paymentType;\n        address paymentAddress;\n        bytes32 paymentPartition;\n        address fundAddress;\n        bool subscriptionsOpened;\n    }\n\n    struct Cycle {\n        address assetAddress;\n        bytes32 assetClass;\n        uint256 startTime;\n        uint256 subscriptionPeriodLength;\n        uint256 valuationPeriodLength;\n        uint256 paymentPeriodLength;\n        AssetValue assetValueType;\n        uint256 assetValue;\n        uint256 reverseAssetValue;\n        Payment paymentType;\n        address paymentAddress;\n        bytes32 paymentPartition;\n        address fundAddress;\n        bool finalized;\n    }\n\n    struct Order {\n        uint256 cycleIndex;\n        address investor;\n        uint256 value;\n        uint256 amount;\n        OrderType orderType;\n        OrderState state;\n    }\n\n    // Mapping from (assetAddress, assetClass) to asset rules.\n    mapping(address => mapping(bytes32 => AssetRules)) internal _assetRules;\n\n    // Index of most recent cycle.\n    uint256 internal _cycleIndex;\n\n    // Mapping from cycle index to cycle.\n    mapping(uint256 => Cycle) internal _cycles;\n\n    // Mapping from (assetAddress, assetClass) to most recent cycle.\n    mapping(address => mapping(bytes32 => uint256)) internal _lastCycleIndex;\n\n    // Index of most recent order.\n    uint256 internal _orderIndex;\n\n    // Mapping from order index to order.\n    mapping(uint256 => Order) internal _orders;\n\n    // Mapping from cycle index to order list.\n    mapping(uint256 => uint256[]) internal _cycleOrders;\n\n    // Mapping from investor address to order list.\n    mapping(address => uint256[]) internal _investorOrders;\n\n    // Mapping from assetAddress to amount of escrowed ETH.\n    mapping(address => uint256) internal _escrowedEth;\n\n    // Mapping from (assetAddress, paymentAddress) to amount of escrowed ERC20.\n    mapping(address => mapping(address => uint256)) internal _escrowedErc20;\n\n    // Mapping from (assetAddress, paymentAddress, paymentPartition) to amount of escrowed ERC1400.\n    mapping(address => mapping(address => mapping(bytes32 => uint256)))\n        internal _escrowedErc1400;\n\n    // Mapping from token to token controllers.\n    mapping(address => address[]) internal _tokenControllers;\n\n    // Mapping from (token, operator) to token controller status.\n    mapping(address => mapping(address => bool)) internal _isTokenController;\n\n    // Mapping from token to price oracles.\n    mapping(address => address[]) internal _priceOracles;\n\n    // Mapping from (token, operator) to price oracle status.\n    mapping(address => mapping(address => bool)) internal _isPriceOracle;\n\n    /**\n     * @dev Modifier to verify if sender is a token controller.\n     */\n    modifier onlyTokenController(address tokenAddress) {\n        require(\n            _tokenController(msg.sender, tokenAddress),\n            \"Sender is not a token controller.\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is a price oracle.\n     */\n    modifier onlyPriceOracle(address assetAddress) {\n        require(\n            _checkPriceOracle(assetAddress, msg.sender),\n            \"Sender is not a price oracle.\"\n        );\n        _;\n    }\n\n    /**\n     * [DVP CONSTRUCTOR]\n     * @dev Initialize Fund issuance contract + register\n     * the contract implementation in ERC1820Registry.\n     */\n    constructor() public {\n        ERC1820Implementer._setInterface(FUND_ISSUER);\n        ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n        setInterfaceImplementation(ERC1400_TOKENS_RECIPIENT, address(this));\n    }\n\n    /**\n     * [ERC1400TokensRecipient INTERFACE (1/2)]\n     * @dev Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]\n     * @param data Information attached to the token transfer.\n     * @param operatorData Information attached to the DVP transfer, by the operator.\n     * @return 'true' if the DVP contract can receive the tokens, 'false' if not.\n     */\n    function canReceive(\n        bytes calldata,\n        bytes32,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external view returns (bool) {\n        return (_canReceive(data, operatorData));\n    }\n\n    /**\n     * [ERC1400TokensRecipient INTERFACE (2/2)]\n     * @dev Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]\n     * @param partition Name of the partition.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the token transfer.\n     * @param operatorData Information attached to the DVP transfer, by the operator.\n     */\n    function tokensReceived(\n        bytes calldata,\n        bytes32 partition,\n        address,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        require(interfaceAddr(msg.sender, \"ERC1400Token\") == msg.sender, \"55\"); // 0x55 funds locked (lockup period)\n\n        require(to == address(this), \"50\"); // 0x50\ttransfer failure\n        require(_canReceive(data, operatorData), \"57\"); // 0x57\tinvalid receiver\n\n        bytes32 flag = _getTransferFlag(data);\n        bytes memory erc1400TokenData = abi.encode(\n            msg.sender,\n            partition,\n            value\n        );\n\n        if (flag == ORDER_SUBSCRIPTION_FLAG) {\n            address assetAddress = _getAssetAddress(data);\n            bytes32 assetClass = _getAssetClass(data);\n            bytes memory orderData = _getOrderData(data);\n\n            _subscribe(\n                from,\n                assetAddress,\n                assetClass,\n                orderData,\n                true,\n                erc1400TokenData\n            );\n        } else if (flag == ORDER_PAYMENT_FLAG) {\n            uint256 orderIndex = _getOrderIndex(data);\n            Order storage order = _orders[orderIndex];\n            require(\n                from == order.investor,\n                \"Payment sender is not the subscriber\"\n            );\n\n            _executePayment(orderIndex, erc1400TokenData, false);\n        }\n    }\n\n    /**\n     * @dev Start a new subscription for a given asset in the fund issuance smart contract.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @param subscriptionPeriodLength Length of subscription period.\n     * @param valuationPeriodLength Length of valuation period.\n     * @param paymentPeriodLength Length of payment period.\n     * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).\n     * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).\n     * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).\n     * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.\n     */\n    function setAssetRules(\n        address assetAddress,\n        bytes32 assetClass,\n        uint256 firstStartTime,\n        uint256 subscriptionPeriodLength,\n        uint256 valuationPeriodLength,\n        uint256 paymentPeriodLength,\n        Payment paymentType,\n        address paymentAddress,\n        bytes32 paymentPartition,\n        address fundAddress,\n        bool subscriptionsOpened\n    ) external onlyTokenController(assetAddress) {\n        AssetRules storage rules = _assetRules[assetAddress][assetClass];\n\n        require(\n            firstStartTime >= block.timestamp,\n            \"First cycle start can not be prior to now\"\n        );\n\n        require(\n            subscriptionPeriodLength != 0 &&\n                valuationPeriodLength != 0 &&\n                paymentPeriodLength != 0,\n            \"Periods can not be nil\"\n        );\n\n        if (rules.defined) {\n            rules.firstStartTime = firstStartTime;\n            rules.subscriptionPeriodLength = subscriptionPeriodLength;\n            rules.valuationPeriodLength = valuationPeriodLength;\n            rules.paymentPeriodLength = paymentPeriodLength;\n            // rules.assetValueType = assetValueType; // Can only be modified by the price oracle\n            // rules.assetValue = assetValue; // Can only be modified by the price oracle\n            // rules.reverseAssetValue = reverseAssetValue; // Can only be modified by the price oracle\n            rules.paymentType = paymentType;\n            rules.paymentAddress = paymentAddress;\n            rules.paymentPartition = paymentPartition;\n            rules.fundAddress = fundAddress;\n            rules.subscriptionsOpened = subscriptionsOpened;\n        } else {\n            _assetRules[assetAddress][assetClass] = AssetRules({\n                defined: true,\n                firstStartTime: firstStartTime,\n                subscriptionPeriodLength: subscriptionPeriodLength,\n                valuationPeriodLength: valuationPeriodLength,\n                paymentPeriodLength: paymentPeriodLength,\n                assetValueType: AssetValue.Unknown,\n                assetValue: 0,\n                reverseAssetValue: 0,\n                paymentType: paymentType,\n                paymentAddress: paymentAddress,\n                paymentPartition: paymentPartition,\n                fundAddress: fundAddress,\n                subscriptionsOpened: subscriptionsOpened\n            });\n        }\n    }\n\n    /**\n     * @dev Set asset value rules for a given asset.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @param assetValueType Asset value type.\n     * @param assetValue Asset value.\n     * @param reverseAssetValue Reverse asset value.\n     */\n    function setAssetValueRules(\n        address assetAddress,\n        bytes32 assetClass,\n        AssetValue assetValueType,\n        uint256 assetValue,\n        uint256 reverseAssetValue\n    ) external onlyPriceOracle(assetAddress) {\n        AssetRules storage rules = _assetRules[assetAddress][assetClass];\n\n        require(rules.defined, \"Rules not defined for this asset\");\n\n        require(\n            assetValue == 0 || reverseAssetValue == 0,\n            \"Asset value can only be set in one direction\"\n        );\n\n        rules.assetValueType = assetValueType;\n        rules.assetValue = assetValue;\n        rules.reverseAssetValue = reverseAssetValue;\n    }\n\n    /**\n     * @dev Start a new subscription for a given asset in the fund issuance smart contract.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @return Index of new cycle.\n     */\n    function _startNewCycle(address assetAddress, bytes32 assetClass)\n        internal\n        returns (uint256)\n    {\n        AssetRules storage rules = _assetRules[assetAddress][assetClass];\n        require(rules.defined, \"Rules not defined for this asset\");\n        require(\n            rules.subscriptionsOpened,\n            \"Subscriptions not opened for this asset\"\n        );\n\n        uint256 lastCycleIndex = _lastCycleIndex[assetAddress][assetClass];\n        Cycle storage lastCycle = _cycles[lastCycleIndex];\n        uint256 previousStartTime = (lastCycle.startTime != 0)\n            ? lastCycle.startTime\n            : rules.firstStartTime;\n\n        _cycleIndex = _cycleIndex.add(1);\n\n        _cycles[_cycleIndex] = Cycle({\n            assetAddress: assetAddress,\n            assetClass: assetClass,\n            startTime: _getNextStartTime(\n                previousStartTime,\n                rules.subscriptionPeriodLength\n            ),\n            subscriptionPeriodLength: rules.subscriptionPeriodLength,\n            valuationPeriodLength: rules.valuationPeriodLength,\n            paymentPeriodLength: rules.paymentPeriodLength,\n            assetValueType: rules.assetValueType,\n            assetValue: rules.assetValue,\n            reverseAssetValue: rules.reverseAssetValue,\n            paymentType: rules.paymentType,\n            paymentAddress: rules.paymentAddress,\n            paymentPartition: rules.paymentPartition,\n            fundAddress: rules.fundAddress,\n            finalized: false\n        });\n\n        _lastCycleIndex[assetAddress][assetClass] = _cycleIndex;\n\n        return _cycleIndex;\n    }\n\n    /**\n     * @dev Returns time of next cycle start.\n     * @param previousStartTime Previous start time.\n     * @param subscriptionPeriod Time between subscription period start and cut-off.\n     * @return Time of next cycle start.\n     */\n    function _getNextStartTime(\n        uint256 previousStartTime,\n        uint256 subscriptionPeriod\n    ) internal view returns (uint256) {\n        if (previousStartTime >= block.timestamp) {\n            return previousStartTime;\n        } else {\n            return\n                block.timestamp.sub(\n                    (block.timestamp - previousStartTime).mod(\n                        subscriptionPeriod\n                    )\n                );\n        }\n    }\n\n    /**\n     * @dev Subscribe for a given asset, by creating an order.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @param orderValue Value of assets to purchase (used in case order type is 'value').\n     * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').\n     * @param orderType Order type (value | amount).\n     */\n    function subscribe(\n        address assetAddress,\n        bytes32 assetClass,\n        uint256 orderValue,\n        uint256 orderAmount,\n        OrderType orderType,\n        bool executePaymentAtSubscription\n    ) external payable returns (uint256) {\n        bytes memory orderData = abi.encode(orderValue, orderAmount, orderType);\n\n        return\n            _subscribe(\n                msg.sender,\n                assetAddress,\n                assetClass,\n                orderData,\n                executePaymentAtSubscription,\n                new bytes(0)\n            );\n    }\n\n    /**\n     * @dev Subscribe for a given asset, by creating an order.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @param orderData Encoded pack of variables for order (orderValue, orderAmount, orderType).\n     * @param executePaymentAtSubscription 'true' if payment shall be executed at subscription, 'false' if not.\n     * @param erc1400TokenData Encoded pack of variables for erc1400 token (paymentAddress, paymentPartition, paymentValue).\n     */\n    function _subscribe(\n        address investor,\n        address assetAddress,\n        bytes32 assetClass,\n        bytes memory orderData,\n        bool executePaymentAtSubscription,\n        bytes memory erc1400TokenData\n    ) internal returns (uint256) {\n        uint256 lastIndex = _lastCycleIndex[assetAddress][assetClass];\n        CycleState currentState = _getCycleState(lastIndex);\n\n        if (currentState != CycleState.Subscription) {\n            lastIndex = _startNewCycle(assetAddress, assetClass);\n        }\n\n        require(\n            _getCycleState(lastIndex) == CycleState.Subscription,\n            \"Subscription can only be performed during subscription period\"\n        );\n\n        (uint256 value, uint256 amount, OrderType orderType) = abi.decode(\n            orderData,\n            (uint256, uint256, OrderType)\n        );\n\n        require(\n            value == 0 || amount == 0,\n            \"Order can not be of type amount and value at the same time\"\n        );\n\n        if (orderType == OrderType.Value) {\n            require(value != 0, \"Order value shall not be nil\");\n        } else if (orderType == OrderType.Amount) {\n            require(amount != 0, \"Order amount shall not be nil\");\n        } else {\n            revert(\"Order type needs to be value or amount\");\n        }\n\n        _orderIndex++;\n\n        _orders[_orderIndex] = Order({\n            cycleIndex: lastIndex,\n            investor: investor,\n            value: value,\n            amount: amount,\n            orderType: orderType,\n            state: OrderState.Subscribed\n        });\n\n        _cycleOrders[lastIndex].push(_orderIndex);\n\n        _investorOrders[investor].push(_orderIndex);\n\n        Cycle storage cycle = _cycles[lastIndex];\n        if (\n            cycle.assetValueType == AssetValue.Known &&\n            executePaymentAtSubscription\n        ) {\n            _executePayment(_orderIndex, erc1400TokenData, false);\n        }\n\n        return _orderIndex;\n    }\n\n    /**\n     * @dev Cancel an order.\n     * @param orderIndex Index of the order to cancel.\n     */\n    function cancelOrder(uint256 orderIndex) external {\n        Order storage order = _orders[orderIndex];\n\n        require(\n            order.state == OrderState.Subscribed ||\n                order.state == OrderState.Paid,\n            \"Only subscribed or paid orders can be cancelled\"\n        ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n        require(\n            _getCycleState(order.cycleIndex) < CycleState.Valuation,\n            \"Orders can only be cancelled before cut-off\"\n        );\n\n        require(msg.sender == order.investor);\n\n        if (order.state == OrderState.Paid) {\n            _releasePayment(orderIndex, order.investor);\n        }\n\n        order.state = OrderState.Cancelled;\n    }\n\n    /**\n     * @dev Reject an order.\n     * @param orderIndex Index of the order to reject.\n     * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled\n     */\n    function rejectOrder(uint256 orderIndex, bool rejected) external {\n        Order storage order = _orders[orderIndex];\n\n        require(\n            order.state == OrderState.Subscribed ||\n                order.state == OrderState.Paid ||\n                order.state == OrderState.Rejected,\n            \"Order rejection can only handled for subscribed or paid orders\"\n        ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n        require(\n            _getCycleState(order.cycleIndex) < CycleState.Payment,\n            \"Orders can only be rejected before beginning of payment phase\"\n        );\n\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        require(\n            _tokenController(msg.sender, cycle.assetAddress),\n            \"Sender is not a token controller.\"\n        );\n\n        if (rejected) {\n            if (order.state == OrderState.Paid) {\n                _releasePayment(orderIndex, order.investor);\n            }\n            order.state = OrderState.Rejected;\n        } else {\n            order.state = OrderState.Subscribed;\n        }\n    }\n\n    /**\n     * @dev Set assetValue for a given asset.\n     * @param cycleIndex Index of the cycle where assetValue needs to be set.\n     * @param assetValue Units of cash required for a unit of asset.\n     * @param reverseAssetValue Units of asset required for a unit of cash.\n     */\n    function valuate(\n        uint256 cycleIndex,\n        uint256 assetValue,\n        uint256 reverseAssetValue\n    ) external {\n        Cycle storage cycle = _cycles[cycleIndex];\n        CycleState cycleState = _getCycleState(cycleIndex);\n\n        require(\n            cycleState > CycleState.Subscription &&\n                cycleState < CycleState.Payment,\n            \"AssetValue can only be set during valuation period\"\n        );\n\n        require(\n            cycle.assetValueType == AssetValue.Unknown,\n            \"Asset value can only be set for a cycle of type unkonwn\"\n        );\n\n        require(\n            assetValue == 0 || reverseAssetValue == 0,\n            \"Asset value can only be set in one direction\"\n        );\n\n        require(\n            _checkPriceOracle(cycle.assetAddress, msg.sender),\n            \"Sender is not a price oracle.\"\n        );\n\n        cycle.assetValue = assetValue;\n        cycle.reverseAssetValue = reverseAssetValue;\n    }\n\n    /**\n     * @dev Execute payment for a given order.\n     * @param orderIndex Index of the order to declare as paid.\n     */\n    function executePaymentAsInvestor(uint256 orderIndex) external payable {\n        Order storage order = _orders[orderIndex];\n\n        require(msg.sender == order.investor);\n\n        _executePayment(orderIndex, new bytes(0), false);\n    }\n\n    /**\n     * @dev Set payment as executed for a given order.\n     * @param orderIndex Index of the order to declare as paid.\n     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n     */\n    function executePaymentAsController(uint256 orderIndex, bool bypassPayment)\n        external\n    {\n        Order storage order = _orders[orderIndex];\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        require(\n            _tokenController(msg.sender, cycle.assetAddress),\n            \"Sender is not a token controller.\"\n        );\n\n        _executePayment(orderIndex, new bytes(0), bypassPayment);\n    }\n\n    /**\n     * @dev Set payments as executed for a batch of given orders.\n     * @param orderIndexes Indexes of the orders to declare as paid.\n     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n     */\n    function batchExecutePaymentsAsController(\n        uint256[] calldata orderIndexes,\n        bool bypassPayment\n    ) external {\n        for (uint256 i = 0; i < orderIndexes.length; i++) {\n            Order storage order = _orders[orderIndexes[i]];\n            Cycle storage cycle = _cycles[order.cycleIndex];\n\n            require(\n                _tokenController(msg.sender, cycle.assetAddress),\n                \"Sender is not a token controller.\"\n            );\n\n            _executePayment(orderIndexes[i], new bytes(0), bypassPayment);\n        }\n    }\n\n    /**\n     * @dev Pay for a given order.\n     * @param orderIndex Index of the order to declare as paid.\n     * @param erc1400TokenData Encoded pack of variables for erc1400 token (paymentAddress, paymentPartition, paymentValue).\n     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)\n     */\n    function _executePayment(\n        uint256 orderIndex,\n        bytes memory erc1400TokenData,\n        bool bypassPayment\n    ) internal {\n        Order storage order = _orders[orderIndex];\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        require(\n            order.state == OrderState.Subscribed ||\n                order.state == OrderState.UnpaidSettled,\n            \"Order is neither in state Subscribed, nor UnpaidSettled\"\n        ); // This also checks if the order exists. Otherwise, we would have \"order.state == OrderState.Undefined\"\n\n        require(!cycle.finalized, \"Cycle is already finalized\");\n\n        if (cycle.assetValueType == AssetValue.Unknown) {\n            require(\n                _getCycleState(order.cycleIndex) >= CycleState.Payment,\n                \"Payment can only be performed after valuation period\"\n            );\n        } else {\n            require(\n                _getCycleState(order.cycleIndex) >= CycleState.Subscription,\n                \"Payment can only be performed after start of subscription period\"\n            );\n        }\n\n        require(\n            order.orderType == OrderType.Value ||\n                order.orderType == OrderType.Amount,\n            \"Invalid order type\"\n        );\n\n        (uint256 amount, uint256 value) = _getOrderAmountAndValue(orderIndex);\n        order.amount = amount;\n        order.value = value;\n\n        if (!bypassPayment) {\n            if (cycle.paymentType == Payment.ETH) {\n                require(msg.value == value, \"Amount of ETH is not correct\");\n                _escrowedEth[cycle.assetAddress] += value;\n            } else if (cycle.paymentType == Payment.ERC20) {\n                ERC20(cycle.paymentAddress).transferFrom(\n                    msg.sender,\n                    address(this),\n                    value\n                );\n                _escrowedErc20[cycle.assetAddress][cycle\n                    .paymentAddress] += value;\n            } else if (\n                cycle.paymentType == Payment.ERC1400 &&\n                erc1400TokenData.length == 0\n            ) {\n                ERC1400(cycle.paymentAddress).operatorTransferByPartition(\n                    cycle.paymentPartition,\n                    msg.sender,\n                    address(this),\n                    value,\n                    abi.encodePacked(BYPASS_ACTION_FLAG),\n                    abi.encodePacked(BYPASS_ACTION_FLAG)\n                );\n                _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle\n                    .paymentPartition] += value;\n            } else if (\n                cycle.paymentType == Payment.ERC1400 &&\n                erc1400TokenData.length != 0\n            ) {\n                (\n                    address erc1400TokenAddress,\n                    bytes32 erc1400TokenPartition,\n                    uint256 erc1400PaymentValue\n                ) = abi.decode(erc1400TokenData, (address, bytes32, uint256));\n                require(erc1400PaymentValue == value, \"wrong payment value\");\n                require(\n                    Payment.ERC1400 == cycle.paymentType,\n                    \"ERC1400 payment is not accecpted for this asset\"\n                );\n                require(\n                    erc1400TokenAddress == cycle.paymentAddress,\n                    \"wrong payment token address\"\n                );\n                require(\n                    erc1400TokenPartition == cycle.paymentPartition,\n                    \"wrong payment token partition\"\n                );\n                _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle\n                    .paymentPartition] += value;\n            } else {\n                revert(\"off-chain payment needs to be bypassed\");\n            }\n        }\n\n        if (order.state == OrderState.UnpaidSettled) {\n            _releasePayment(orderIndex, cycle.fundAddress);\n            order.state = OrderState.PaidSettled;\n        } else {\n            order.state = OrderState.Paid;\n        }\n    }\n\n    /**\n     * @dev Retrieve order amount and order value calculated based on cycle valuation.\n     * @param orderIndex Index of the order.\n     * @return Order amount.\n     * @return Order value.\n     */\n    function _getOrderAmountAndValue(uint256 orderIndex)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        Order storage order = _orders[orderIndex];\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        uint256 value;\n        uint256 amount;\n        if (order.orderType == OrderType.Value) {\n            value = order.value;\n            if (cycle.assetValue != 0) {\n                amount = value.div(cycle.assetValue);\n            } else {\n                amount = value.mul(cycle.reverseAssetValue);\n            }\n        }\n\n        if (order.orderType == OrderType.Amount) {\n            amount = order.amount;\n            if (cycle.assetValue != 0) {\n                value = amount.mul(cycle.assetValue);\n            } else {\n                value = amount.div(cycle.reverseAssetValue);\n            }\n        }\n\n        return (amount, value);\n    }\n\n    /**\n     * @dev Release payment for a given order.\n     * @param orderIndex Index of the order of the payment to be sent.\n     * @param recipient Address to receive to the payment.\n     */\n    function _releasePayment(uint256 orderIndex, address recipient) internal {\n        Order storage order = _orders[orderIndex];\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        if (cycle.paymentType == Payment.ETH) {\n            address payable refundAddress = address(uint160(recipient));\n            refundAddress.transfer(order.value);\n            _escrowedEth[cycle.assetAddress] -= order.value;\n        } else if (cycle.paymentType == Payment.ERC20) {\n            ERC20(cycle.paymentAddress).transfer(recipient, order.value);\n            _escrowedErc20[cycle.assetAddress][cycle.paymentAddress] -= order\n                .value;\n        } else if (cycle.paymentType == Payment.ERC1400) {\n            ERC1400(cycle.paymentAddress).transferByPartition(\n                cycle.paymentPartition,\n                recipient,\n                order.value,\n                abi.encodePacked(BYPASS_ACTION_FLAG)\n            );\n            _escrowedErc1400[cycle.assetAddress][cycle.paymentAddress][cycle\n                .paymentPartition] -= order.value;\n        }\n    }\n\n    /**\n     * @dev Settle a given order.\n     * @param orderIndex Index of the order to settle.\n     */\n    function settleOrder(uint256 orderIndex) internal {\n        Order storage order = _orders[orderIndex];\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        require(\n            _tokenController(msg.sender, cycle.assetAddress),\n            \"Sender is not a token controller.\"\n        );\n\n        _settleOrder(orderIndex);\n    }\n\n    /**\n     * @dev Settle a batch of given orders.\n     * @param orderIndexes Indexes of the orders to settle.\n     */\n    function batchSettleOrders(uint256[] calldata orderIndexes) external {\n        for (uint256 i = 0; i < orderIndexes.length; i++) {\n            Order storage order = _orders[orderIndexes[i]];\n            Cycle storage cycle = _cycles[order.cycleIndex];\n\n            require(\n                _tokenController(msg.sender, cycle.assetAddress),\n                \"Sender is not a token controller.\"\n            );\n\n            _settleOrder(orderIndexes[i]);\n        }\n    }\n\n    /**\n     * @dev Settle a given order.\n     * @param orderIndex Index of the order to settle.\n     */\n    function _settleOrder(uint256 orderIndex) internal {\n        Order storage order = _orders[orderIndex];\n\n        require(order.state > OrderState.Undefined, \"Order doesnt exist\");\n\n        CycleState currentState = _getCycleState(order.cycleIndex);\n\n        Cycle storage cycle = _cycles[order.cycleIndex];\n\n        if (cycle.assetValueType == AssetValue.Unknown) {\n            require(\n                currentState >= CycleState.Settlement,\n                \"Order settlement can only be performed during settlement period\"\n            );\n        } else {\n            require(\n                currentState >= CycleState.Valuation,\n                \"Order settlement can only be performed after the cut-off\"\n            );\n        }\n\n        _releasePayment(orderIndex, cycle.fundAddress);\n\n        if (order.state == OrderState.Paid) {\n            ERC1400(cycle.assetAddress).issueByPartition(\n                cycle.assetClass,\n                order.investor,\n                order.amount,\n                \"\"\n            );\n            order.state = OrderState.PaidSettled;\n        } else if (order.state == OrderState.Subscribed) {\n            ERC1400(cycle.assetAddress).issueByPartition(\n                cycle.assetClass,\n                address(this),\n                order.amount,\n                \"\"\n            );\n            order.state = OrderState.UnpaidSettled;\n        } else {\n            revert(\n                \"Impossible to settle an order that is neither in state Paid, nor Subscribed\"\n            );\n        }\n    }\n\n    /**\n     * @dev Finalize a given cycle.\n     * @param cycleIndex Index of the cycle to finalize.\n     */\n    function finalizeCycle(uint256 cycleIndex) external {\n        Cycle storage cycle = _cycles[cycleIndex];\n\n        require(\n            _tokenController(msg.sender, cycle.assetAddress),\n            \"Sender is not a token controller.\"\n        );\n\n        require(!cycle.finalized, \"Cycle is already finalized\");\n\n        (\n            ,\n            uint256 totalUnpaidSettled,\n            bool remainingOrdersToSettle\n        ) = _getTotalSettledForCycle(cycleIndex);\n\n        if (!remainingOrdersToSettle) {\n            cycle.finalized = true;\n            if (totalUnpaidSettled != 0) {\n                ERC1400(cycle.assetAddress).transferByPartition(\n                    cycle.assetClass,\n                    cycle.fundAddress,\n                    totalUnpaidSettled,\n                    \"\"\n                );\n            }\n        } else {\n            revert(\"Remaining orders to settle\");\n        }\n    }\n\n    /**\n     * @dev Retrieve sum of paid/unpaid settled orders for a given cycle.\n     *\n     * @param cycleIndex Index of the cycle.\n     * @return Sum of paid settled orders.\n     * @return Sum of unpaid settled orders.\n     * @return 'True' if there are remaining orders to settle, 'false' if not.\n     */\n    function getTotalSettledForCycle(uint256 cycleIndex)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        return _getTotalSettledForCycle(cycleIndex);\n    }\n\n    /**\n     * @dev Retrieve sum of paid/unpaid settled orders for a given cycle.\n     *\n     * @param cycleIndex Index of the cycle.\n     * @return Sum of paid settled orders.\n     * @return Sum of unpaid settled orders.\n     * @return 'True' if there are remaining orders to settle, 'false' if not.\n     */\n    function _getTotalSettledForCycle(uint256 cycleIndex)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        uint256 totalPaidSettled;\n        uint256 totalUnpaidSettled;\n        bool remainingOrdersToSettle;\n\n        for (uint256 i = 0; i < _cycleOrders[cycleIndex].length; i++) {\n            Order storage order = _orders[_cycleOrders[cycleIndex][i]];\n\n            if (order.state == OrderState.PaidSettled) {\n                totalPaidSettled = totalPaidSettled.add(order.amount);\n            } else if (order.state == OrderState.UnpaidSettled) {\n                totalUnpaidSettled = totalUnpaidSettled.add(order.amount);\n            } else if (\n                order.state != OrderState.Cancelled &&\n                order.state != OrderState.Rejected\n            ) {\n                remainingOrdersToSettle = true;\n            }\n        }\n\n        return (totalPaidSettled, totalUnpaidSettled, remainingOrdersToSettle);\n    }\n\n    /**\n     * @dev Retrieve the current state of the cycle.\n     *\n     * @param cycleIndex Index of the cycle.\n     * @return Cycle state.\n     */\n    function getCycleState(uint256 cycleIndex)\n        external\n        view\n        returns (CycleState)\n    {\n        return _getCycleState(cycleIndex);\n    }\n\n    /**\n     * @dev Retrieve the current state of the cycle.\n     *\n     * @param cycleIndex Index of the cycle.\n     * @return Cycle state.\n     */\n    function _getCycleState(uint256 cycleIndex)\n        internal\n        view\n        returns (CycleState)\n    {\n        Cycle storage cycle = _cycles[cycleIndex];\n\n        if (block.timestamp < cycle.startTime || cycle.startTime == 0) {\n            return CycleState.Undefined;\n        } else if (\n            block.timestamp < cycle.startTime + cycle.subscriptionPeriodLength\n        ) {\n            return CycleState.Subscription;\n        } else if (\n            block.timestamp <\n            cycle.startTime +\n                cycle.subscriptionPeriodLength +\n                cycle.valuationPeriodLength\n        ) {\n            return CycleState.Valuation;\n        } else if (\n            block.timestamp <\n            cycle.startTime +\n                cycle.subscriptionPeriodLength +\n                cycle.valuationPeriodLength +\n                cycle.paymentPeriodLength\n        ) {\n            return CycleState.Payment;\n        } else if (!cycle.finalized) {\n            return CycleState.Settlement;\n        } else {\n            return CycleState.Finalized;\n        }\n    }\n\n    /**\n     * @dev Check if the sender is a token controller.\n     *\n     * @param sender Transaction sender.\n     * @param assetAddress Address of the token representing the asset.\n     * @return Returns 'true' if sender is a token controller.\n     */\n    function _tokenController(address sender, address assetAddress)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            sender == Ownable(assetAddress).owner() ||\n            _isTokenController[assetAddress][sender]\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Indicate whether or not the fund issuance contract can receive the tokens.\n     *\n     * By convention, the 32 first bytes of a token transfer to the fund issuance smart contract contain a flag.\n     *\n     *  - When tokens are transferred to fund issuance contract to create a new order, the 'data' field starts with the\n     *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *  In this case the data structure is the the following:\n     *  <transferFlag (32 bytes)><asset address (32 bytes)><asset class (32 bytes)><order data (3 * 32 bytes)>\n     *\n     *  - When tokens are transferred to fund issuance contract to pay for an existing order, the 'data' field starts with the\n     *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *  In this case the data structure is the the following:\n     *  <transferFlag (32 bytes)><order index (32 bytes)>\n     *\n     * If the 'data' doesn't start with one of those flags, the fund issuance contract won't accept the token transfer.\n     *\n     * @param data Information attached to the token transfer to fund issuance contract.\n     * @param operatorData Information attached to the token transfer to fund issuance contract, by the operator.\n     * @return 'true' if the fund issuance contract can receive the tokens, 'false' if not.\n     */\n    function _canReceive(bytes memory data, bytes memory operatorData)\n        internal\n        pure\n        returns (bool)\n    {\n        if (operatorData.length == 0) {\n            // The reason for this check is to avoid a certificate gets interpreted as a flag by mistake\n            return false;\n        }\n\n        bytes32 flag = _getTransferFlag(data);\n        if (data.length == 192 && flag == ORDER_SUBSCRIPTION_FLAG) {\n            return true;\n        } else if (data.length == 64 && flag == ORDER_PAYMENT_FLAG) {\n            return true;\n        } else if (data.length == 32 && flag == BYPASS_ACTION_FLAG) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Retrieve the transfer flag from the 'data' field.\n     *\n     * By convention, the 32 first bytes of a token transfer to the fund issuance smart contract contain a flag.\n     *  - When tokens are transferred to fund issuance contract to create a new order, the 'data' field starts with the\n     *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *  - When tokens are transferred to fund issuance contract to pay for an existing order, the 'data' field starts with the\n     *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *\n     * @param data Concatenated information about the transfer.\n     * @return Transfer flag.\n     */\n    function _getTransferFlag(bytes memory data)\n        internal\n        pure\n        returns (bytes32 flag)\n    {\n        assembly {\n            flag := mload(add(data, 32))\n        }\n    }\n\n    /**\n     * By convention, when tokens are transferred to fund issuance contract to create a new order, the 'data' of a token transfer has the following structure:\n     *  <transferFlag (32 bytes)><asset address (32 bytes)><asset class (32 bytes)><order data (3 * 32 bytes)>\n     *\n     * The first 32 bytes are the flag 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *\n     * The next 32 bytes contain the order index.\n     *\n     * Example input for asset address '0xb5747835141b46f7C472393B31F8F5A57F74A44f',\n     * asset class '37252', order type 'Value', and value 12000\n     * 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc000000000000000000000000b5747835141b46f7C472393B31F8F5A57F74A44f\n     * 000000000000000000000000000000000000000000000000000000000037252000000000000000000000000000000000000000000000000000000000000001\n     * 000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000000000000000000000\n     *\n     */\n    function _getAssetAddress(bytes memory data)\n        internal\n        pure\n        returns (address assetAddress)\n    {\n        assembly {\n            assetAddress := mload(add(data, 64))\n        }\n    }\n\n    function _getAssetClass(bytes memory data)\n        internal\n        pure\n        returns (bytes32 assetClass)\n    {\n        assembly {\n            assetClass := mload(add(data, 96))\n        }\n    }\n\n    function _getOrderData(bytes memory data)\n        internal\n        pure\n        returns (bytes memory orderData)\n    {\n        uint256 orderValue;\n        uint256 orderAmount;\n        OrderType orderType;\n        assembly {\n            orderValue := mload(add(data, 128))\n            orderAmount := mload(add(data, 160))\n            orderType := mload(add(data, 192))\n        }\n        orderData = abi.encode(orderValue, orderAmount, orderType);\n    }\n\n    /**\n     * By convention, when tokens are transferred to fund issuance contract to pay for an existing order, the 'data' of a token transfer has the following structure:\n     *  <transferFlag (32 bytes)><order index (32 bytes)>\n     *\n     * The first 32 bytes are the flag 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *\n     * The next 32 bytes contain the order index.\n     *\n     * Example input for order index 3:\n     * 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd000000000000000000000000000000000000000000000000000000000000003\n     *\n     */\n\n    /**\n     * @dev Retrieve the order index from the 'data' field.\n     *\n     * @param data Concatenated information about the order payment.\n     * @return Order index.\n     */\n    function _getOrderIndex(bytes memory data)\n        internal\n        pure\n        returns (uint256 orderIndex)\n    {\n        assembly {\n            orderIndex := mload(add(data, 64))\n        }\n    }\n\n    /************************** TOKEN CONTROLLERS *******************************/\n\n    /**\n     * @dev Get the list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @return List of addresses of all the token controllers for a given token.\n     */\n    function tokenControllers(address tokenAddress)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _tokenControllers[tokenAddress];\n    }\n\n    /**\n     * @dev Set list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @param operators Operators addresses.\n     */\n    function setTokenControllers(\n        address tokenAddress,\n        address[] calldata operators\n    ) external onlyTokenController(tokenAddress) {\n        _setTokenControllers(tokenAddress, operators);\n    }\n\n    /**\n     * @dev Set list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @param operators Operators addresses.\n     */\n    function _setTokenControllers(\n        address tokenAddress,\n        address[] memory operators\n    ) internal {\n        for (uint256 i = 0; i < _tokenControllers[tokenAddress].length; i++) {\n            _isTokenController[tokenAddress][_tokenControllers[tokenAddress][i]] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isTokenController[tokenAddress][operators[j]] = true;\n        }\n        _tokenControllers[tokenAddress] = operators;\n    }\n\n    /************************** TOKEN PRICE ORACLES *******************************/\n\n    /**\n     * @dev Get the list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @return List of addresses of all the price oracles for a given token.\n     */\n    function priceOracles(address tokenAddress)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _priceOracles[tokenAddress];\n    }\n\n    /**\n     * @dev Set list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @param oracles Oracles addresses.\n     */\n    function setPriceOracles(address tokenAddress, address[] calldata oracles)\n        external\n        onlyPriceOracle(tokenAddress)\n    {\n        _setPriceOracles(tokenAddress, oracles);\n    }\n\n    /**\n     * @dev Set list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @param oracles Oracles addresses.\n     */\n    function _setPriceOracles(address tokenAddress, address[] memory oracles)\n        internal\n    {\n        for (uint256 i = 0; i < _priceOracles[tokenAddress].length; i++) {\n            _isPriceOracle[tokenAddress][_priceOracles[tokenAddress][i]] = false;\n        }\n        for (uint256 j = 0; j < oracles.length; j++) {\n            _isPriceOracle[tokenAddress][oracles[j]] = true;\n        }\n        _priceOracles[tokenAddress] = oracles;\n    }\n\n    /**\n     * @dev Check if address is oracle of a given token.\n     * @param tokenAddress Token address.\n     * @param oracle Oracle address.\n     * @return 'true' if the address is oracle of the given token.\n     */\n    function _checkPriceOracle(address tokenAddress, address oracle)\n        internal\n        view\n        returns (bool)\n    {\n        return (_isPriceOracle[tokenAddress][oracle] ||\n            oracle == Ownable(tokenAddress).owner());\n    }\n\n    /**************************** VIEW FUNCTIONS *******************************/\n\n    /**\n     * @dev Get asset rules.\n     * @param assetAddress Address of the asset.\n     * @param assetClass Class of the asset.\n     * @return Asset rules.\n     */\n    function getAssetRules(address assetAddress, bytes32 assetClass)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            Payment,\n            address,\n            bytes32,\n            address,\n            bool\n        )\n    {\n        AssetRules storage rules = _assetRules[assetAddress][assetClass];\n        return (\n            rules.firstStartTime,\n            rules.subscriptionPeriodLength,\n            rules.valuationPeriodLength,\n            rules.paymentPeriodLength,\n            rules.paymentType,\n            rules.paymentAddress,\n            rules.paymentPartition,\n            rules.fundAddress,\n            rules.subscriptionsOpened\n        );\n    }\n\n    /**\n     * @dev Get the cycle asset value rules.\n     * @param assetAddress Address of the asset.\n     * @param assetClass Class of the asset.\n     * @return Asset value rules.\n     */\n    function getAssetValueRules(address assetAddress, bytes32 assetClass)\n        external\n        view\n        returns (\n            AssetValue,\n            uint256,\n            uint256\n        )\n    {\n        AssetRules storage rules = _assetRules[assetAddress][assetClass];\n        return (\n            rules.assetValueType,\n            rules.assetValue,\n            rules.reverseAssetValue\n        );\n    }\n\n    /**\n     * @dev Get total number of cycles in the contract.\n     * @return Number of cycles.\n     */\n    function getNbCycles() external view returns (uint256) {\n        return _cycleIndex;\n    }\n\n    /**\n     * @dev Get the index of the last cycle created for a given asset class.\n     * @param assetAddress Address of the token representing the asset.\n     * @param assetClass Asset class.\n     * @return Cycle index.\n     */\n    function getLastCycleIndex(address assetAddress, bytes32 assetClass)\n        external\n        view\n        returns (uint256)\n    {\n        return _lastCycleIndex[assetAddress][assetClass];\n    }\n\n    /**\n     * @dev Get the cycle.\n     * @param index Index of the cycle.\n     * @return Cycle.\n     */\n    function getCycle(uint256 index)\n        external\n        view\n        returns (\n            address,\n            bytes32,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            Payment,\n            address,\n            bytes32,\n            bool\n        )\n    {\n        Cycle storage cycle = _cycles[index];\n        return (\n            cycle.assetAddress,\n            cycle.assetClass,\n            cycle.startTime,\n            cycle.subscriptionPeriodLength,\n            cycle.valuationPeriodLength,\n            cycle.paymentPeriodLength,\n            cycle.paymentType,\n            cycle.paymentAddress,\n            cycle.paymentPartition,\n            cycle.finalized\n        );\n    }\n\n    /**\n     * @dev Get the cycle asset value.\n     * @param index Index of the cycle.\n     * @return Cycle.\n     */\n    function getCycleAssetValue(uint256 index)\n        external\n        view\n        returns (\n            AssetValue,\n            uint256,\n            uint256\n        )\n    {\n        Cycle storage cycle = _cycles[index];\n        return (\n            cycle.assetValueType,\n            cycle.assetValue,\n            cycle.reverseAssetValue\n        );\n    }\n\n    /**\n     * @dev Get total number of orders in the contract.\n     * @return Number of orders.\n     */\n    function getNbOrders() external view returns (uint256) {\n        return _orderIndex;\n    }\n\n    /**\n     * @dev Retrieve an order.\n     * @param index Index of the order.\n     * @return Order.\n     */\n    function getOrder(uint256 index)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256,\n            uint256,\n            OrderType,\n            OrderState\n        )\n    {\n        Order storage order = _orders[index];\n        return (\n            order.cycleIndex,\n            order.investor,\n            order.value,\n            order.amount,\n            order.orderType,\n            order.state\n        );\n    }\n\n    /**\n     * @dev Retrieve order amount and order value calculated based on cycle valuation.\n     * @param orderIndex Index of the order.\n     * @return Order amount.\n     * @return Order value.\n     */\n    function getOrderAmountAndValue(uint256 orderIndex)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return _getOrderAmountAndValue(orderIndex);\n    }\n\n    /**\n     * @dev Get list of cycle orders.\n     * @param index Index of the cycle.\n     * @return List of cycle orders.\n     */\n    function getCycleOrders(uint256 index)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _cycleOrders[index];\n    }\n\n    /**\n     * @dev Get list of investor orders.\n     * @return List of investor orders.\n     */\n    function getInvestorOrders(address investor)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _investorOrders[investor];\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256('balanceOf(address)')) ^\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n     */\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/tools/DVP.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\n\nimport \"../ERC1820//ERC1820Client.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\n\nimport \"../ERC1400.sol\";\n\n/**\n * @title DVP\n * @dev Delivery-Vs-Payment contract for investor-to-investor token trades.\n * @dev Intended usage:\n * The purpose of the contract is to allow secure token transfers/exchanges between 2 stakeholders (called holder1 and holder2).\n * From now on, an operation in the DVP smart contract (transfer/exchange) is called a trade.\n * Depending on the type of trade, one/multiple token transfers will be executed.\n *\n * The simplified workflow is the following:\n * 1) A trade request is created in the DVP smart contract, it specifies:\n *  - The token holder(s) involved in the trade\n *  - The trade executer (optional)\n *  - An expiration date\n *  - Details on the first token (address, requested amount, standard)\n *  - Details on the second token (address, requested amount, standard)\n *  - Whether the tokens need to be escrowed in the DVP contract or not\n *  - The current status of the trade (pending / executed / forced / cancelled)\n * 2) The trade is accepted by both token holders\n * 3) [OPTIONAL] The trade is approved by token controllers (only if requested by tokens controllers)\n * 4) The trade is executed (either by the executer in case the executer is specified, or by anyone)\n *\n * STANDARD-AGNOSTIC:\n * The DVP smart contract is standard-agnostic, it supports ETH, ERC20, ERC721, ERC1400.\n * The advantage of using an ERC1400 token is to leverages its hook property, thus requiring ONE single\n * transaction (operatorTransferByPartition()) to send tokens to the DVP smart contract instead of TWO\n * with the ERC20 token standard (approve() + transferFrom()).\n *\n * OFF-CHAIN PAYMENT:\n * The contract can be used as escrow contract while waiting for an off-chain payment.\n * Once payment is received off-chain, the token sender realeases the tokens escrowed in\n * the DVP contract to deliver them to the recipient.\n *\n * ESCROW VS SWAP MODE:\n * In case escrow mode is selected, tokens need to be escrowed in DVP smart contract\n * before the trade can occur.\n * In case swap mode is selected, tokens are not escrowed in the DVP. Instead, the DVP\n * contract is only allowed to transfer tokens ON BEHALF of their owners. When trade is\n * executed, an atomic token swap occurs.\n *\n * EXPIRATION DATE:\n * The trade can be cancelled by both parties in case expiration date is passed.\n *\n * CLAIMS:\n * The executer has the ability to force or cancel the trade.\n * In case of disagreement/missing payment, both parties can contact the \"executer\"\n * of the trade to deposit a claim and solve the issue.\n *\n * MARKETPLACE:\n * The contract can be used as a token marketplace. Indeed, when trades are created\n * without specifying the recipient address, anyone can purchase them by sending\n * the requested payment in exchange.\n *\n * PRICE ORACLES:\n * When price oracles are defined, those can define the price at which trades need to be executed.\n * This feature is particularly useful for assets with NAV (net asset value).\n *\n */\ncontract DVP is\n    Ownable,\n    ERC1820Client,\n    IERC1400TokensRecipient,\n    ERC1820Implementer\n{\n    using SafeMath for uint256;\n\n    string internal constant DELIVERY_VS_PAYMENT = \"DeliveryVsPayment\";\n    string\n        internal constant ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n    uint256 internal constant SECONDS_IN_MONTH = 86400 * 30;\n    uint256 internal constant SECONDS_IN_WEEK = 86400 * 7;\n\n    bytes32 internal constant ERC1820_ACCEPT_MAGIC = keccak256(\n        abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")\n    );\n\n    bytes32\n        internal constant TRADE_PROPOSAL_FLAG = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n    bytes32\n        internal constant TRADE_ACCEPTANCE_FLAG = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\n\n    bytes32\n        internal constant BYPASS_ACTION_FLAG = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\n\n    bytes32\n        internal constant ALL_PARTITIONS = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    enum Standard {OffChain, ETH, ERC20, ERC721, ERC1400}\n\n    enum State {Undefined, Pending, Executed, Forced, Cancelled}\n\n    enum TradeType {Escrow, Swap}\n\n    enum Holder {Holder1, Holder2}\n\n    struct Trade {\n        address holder1;\n        address holder2;\n        address executer;\n        uint256 expirationDate;\n        bytes tokenData1;\n        bytes tokenData2;\n        TradeType tradeType;\n        State state;\n    }\n\n    // Index of most recent trade request.\n    uint256 internal _index;\n\n    // Mapping from index to trade requests.\n    mapping(uint256 => Trade) internal _trades;\n\n    // Mapping from token to price oracles.\n    mapping(address => address[]) internal _priceOracles;\n\n    // Mapping from (token, operator) to price oracle status.\n    mapping(address => mapping(address => bool)) internal _isPriceOracle;\n\n    // Mapping from (token1, token2) to price ownership.\n    mapping(address => mapping(address => bool)) internal _priceOwnership;\n\n    // Mapping from (token1, token2, tokenId1, tokenId2) to price.\n    mapping(address => mapping(address => mapping(bytes32 => mapping(bytes32 => uint256))))\n        internal _tokenUnitPricesByPartition;\n\n    // Indicate whether DVP smart contract allows escrow or not.\n    bool internal _isEscrowForbidden;\n\n    // Indicate whether DVP smart contract is owned or not (for instance by an exchange, etc.).\n    bool internal _ownedContract;\n\n    // Array of trade execcuters.\n    address[] internal _tradeExecuters;\n\n    // Mapping from operator to trade executer status.\n    mapping(address => bool) internal _isTradeExecuter;\n\n    // Mapping from token to token controllers.\n    mapping(address => address[]) internal _tokenControllers;\n\n    // Mapping from (token, operator) to token controller status.\n    mapping(address => mapping(address => bool)) internal _isTokenController;\n\n    // Mapping from token to variable price start date.\n    mapping(address => uint256) internal _variablePriceStartDate;\n\n    /**\n     * @dev Modifier to verify if sender is a token controller.\n     */\n    modifier onlyTokenController(address tokenAddress) {\n        require(\n            msg.sender == Ownable(tokenAddress).owner() ||\n                _isTokenController[tokenAddress][msg.sender],\n            \"Sender is not a token controller.\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is a price oracle.\n     */\n    modifier onlyPriceOracle(address tokenAddress) {\n        require(\n            _checkPriceOracle(tokenAddress, msg.sender),\n            \"Sender is not a price oracle.\"\n        );\n        _;\n    }\n\n    /**\n     * [DVP CONSTRUCTOR]\n     * @dev Initialize DVP + register\n     * the contract implementation in ERC1820Registry.\n     */\n    constructor(bool owned, bool escrowForbidden) public {\n        ERC1820Implementer._setInterface(DELIVERY_VS_PAYMENT);\n        ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n        setInterfaceImplementation(ERC1400_TOKENS_RECIPIENT, address(this));\n\n        _ownedContract = owned;\n        _isEscrowForbidden = escrowForbidden;\n\n        if (_ownedContract) {\n            address[] memory initialTradeExecuters = new address[](1);\n            initialTradeExecuters[0] = msg.sender;\n            _setTradeExecuters(initialTradeExecuters);\n        }\n    }\n\n    /**\n     * [ERC1400TokensRecipient INTERFACE (1/2)]\n     * @dev Indicate whether or not the DVP contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]\n     * @param data Information attached to the token transfer.\n     * @param operatorData Information attached to the DVP transfer, by the operator.\n     * @return 'true' if the DVP contract can receive the tokens, 'false' if not.\n     */\n    function canReceive(\n        bytes calldata,\n        bytes32,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external view returns (bool) {\n        return (_canReceive(data, operatorData));\n    }\n\n    /**\n     * [ERC1400TokensRecipient INTERFACE (2/2)]\n     * @dev Hook function executed when tokens are sent to the DVP contract. [USED FOR ERC1400 TOKENS ONLY]\n     * @param partition Name of the partition.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the token transfer.\n     * @param operatorData Information attached to the DVP transfer, by the operator.\n     */\n    function tokensReceived(\n        bytes calldata,\n        bytes32 partition,\n        address,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        require(interfaceAddr(msg.sender, \"ERC1400Token\") == msg.sender, \"55\"); // funds locked (lockup period)\n\n        require(to == address(this), \"50\"); // 0x50\ttransfer failure\n        require(_canReceive(data, operatorData), \"57\"); // 0x57\tinvalid receiver\n\n        bytes32 flag = _getTradeFlag(data);\n        if (flag == TRADE_PROPOSAL_FLAG) {\n            address _recipient = _getTradeRecipient(data);\n            address _executer = _getTradeExecuter(data);\n            uint256 _expirationDate = _getTradeExpirationDate(data);\n\n            // Token data: < 1: address > < 2: amount > < 3: id/partition > < 4: standard > < 5: accepted > < 6: approved >\n            bytes memory _tokenData1 = abi.encode(\n                msg.sender,\n                value,\n                partition,\n                Standard.ERC1400,\n                true,\n                false\n            );\n            bytes memory _tokenData2 = _getTradeTokenData(data);\n\n            _requestTrade(\n                from,\n                _recipient,\n                _executer,\n                _expirationDate,\n                _tokenData1,\n                _tokenData2,\n                TradeType.Escrow\n            );\n        } else if (flag == TRADE_ACCEPTANCE_FLAG) {\n            uint256 index = _getTradeIndex(data);\n            Trade storage trade = _trades[index];\n\n            bytes memory selectedTokenData = (from == trade.holder1)\n                ? trade.tokenData1\n                : trade.tokenData2;\n            (address tokenAddress, , , , , ) = abi.decode(\n                selectedTokenData,\n                (address, uint256, bytes32, Standard, bool, bool)\n            );\n            require(msg.sender == tokenAddress, \"Wrong token sent\");\n\n            (, , bytes32 tokenId, , , ) = abi.decode(\n                selectedTokenData,\n                (address, uint256, bytes32, Standard, bool, bool)\n            );\n            require(partition == tokenId, \"Tokens of the wrong partition sent\");\n\n            (, , , Standard tokenStandard, , ) = abi.decode(\n                selectedTokenData,\n                (address, uint256, bytes32, Standard, bool, bool)\n            );\n            require(\n                Standard.ERC1400 == tokenStandard,\n                \"Tokens of the wrong standard sent\"\n            );\n\n            _acceptTrade(index, from, 0, value);\n        }\n    }\n\n    /**\n     * @dev Create a new trade request in the DVP smart contract.\n     * @param holder1 Address of the first token holder.\n     * @param holder2 Address of the second token holder.\n     * @param executer Executer of the trade.\n     * @param expirationDate Expiration date of the trade.\n     * @param tokenAddress1 Address of the first token smart contract.\n     * @param tokenValue1 Amount of tokens to send for the first token.\n     * @param tokenId1 ID/partition of the first token.\n     * @param tokenStandard1 Standard of the first token (ETH | ERC20 | ERC721 | ERC1400).\n     * @param tokenAddress2 Address of the second token smart contract.\n     * @param tokenValue2 Amount of tokens to send for the second token.\n     * @param tokenId2 ID/partition of the second token.\n     * @param tokenStandard2 Standard of the second token (ETH | ERC20 | ERC721 | ERC1400).\n     * @param tradeType Indicates whether or not tokens shall be escrowed in the DVP contract before the trade.\n     */\n    function requestTrade(\n        address holder1,\n        address holder2,\n        address executer, // Set to address(0) if no executer is required for the trade\n        uint256 expirationDate,\n        address tokenAddress1,\n        uint256 tokenValue1,\n        bytes32 tokenId1,\n        Standard tokenStandard1,\n        address tokenAddress2, // Set to address(0) if no token is expected in return (for example in case of an off-chain payment)\n        uint256 tokenValue2,\n        bytes32 tokenId2,\n        Standard tokenStandard2,\n        TradeType tradeType\n    ) external payable {\n        // Token data: < 1: address > < 2: amount > < 3: id/partition > < 4: standard > < 5: accepted > < 6: approved >\n        bytes memory _tokenData1 = abi.encode(\n            tokenAddress1,\n            tokenValue1,\n            tokenId1,\n            tokenStandard1,\n            false,\n            false\n        );\n        bytes memory _tokenData2 = abi.encode(\n            tokenAddress2,\n            tokenValue2,\n            tokenId2,\n            tokenStandard2,\n            false,\n            false\n        );\n\n        _requestTrade(\n            holder1,\n            holder2,\n            executer,\n            expirationDate,\n            _tokenData1,\n            _tokenData2,\n            tradeType\n        );\n\n        if (msg.sender == holder1 || msg.sender == holder2) {\n            _acceptTrade(_index, msg.sender, msg.value, 0);\n        }\n    }\n\n    /**\n     * @dev Create a new trade request in the DVP smart contract.\n     * @param holder1 Address of the first token holder.\n     * @param holder2 Address of the second token holder.\n     * @param executer Executer of the trade.\n     * @param expirationDate Expiration date of the trade.\n     * @param tokenData1 Encoded pack of variables for token1 (address, amount, id/partition, standard, accepted, approved).\n     * @param tokenData2 Encoded pack of variables for token2 (address, amount, id/partition, standard, accepted, approved).\n     * @param tradeType Indicates whether or not tokens shall be escrowed in the DVP contract before the trade.\n     */\n    function _requestTrade(\n        address holder1,\n        address holder2,\n        address executer, // Set to address(0) if no executer is required for the trade\n        uint256 expirationDate,\n        bytes memory tokenData1,\n        bytes memory tokenData2,\n        TradeType tradeType\n    ) internal {\n        (, , , Standard standard1, , ) = abi.decode(\n            tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (, , , Standard standard2, , ) = abi.decode(\n            tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        if (standard1 == Standard.ETH || standard2 == Standard.ETH) {\n            require(\n                tradeType == TradeType.Escrow,\n                \"Ether trades need to be of type Escrow\"\n            );\n        }\n\n        if (_ownedContract) {\n            require(\n                _isTradeExecuter[executer],\n                \"Trade executer needs to belong to the list of allowed trade executers\"\n            );\n        }\n\n        if (_isEscrowForbidden) {\n            require(\n                tradeType != TradeType.Escrow,\n                \"This DVP contract doesn't allow Escrows\"\n            );\n        }\n\n        require(\n            holder1 != address(0),\n            \"A trade can not be created with the zero address\"\n        );\n\n        _index++;\n\n        uint256 _expirationDate = (expirationDate > block.timestamp)\n            ? expirationDate\n            : (block.timestamp + SECONDS_IN_MONTH);\n\n        _trades[_index] = Trade({\n            holder1: holder1,\n            holder2: holder2,\n            executer: executer,\n            expirationDate: _expirationDate,\n            tokenData1: tokenData1,\n            tokenData2: tokenData2,\n            tradeType: tradeType,\n            state: State.Pending\n        });\n    }\n\n    /**\n     * @dev Accept a given trade (+ potentially escrow tokens).\n     * @param index Index of the trade to be accepted.\n     */\n    function acceptTrade(uint256 index) external payable {\n        _acceptTrade(index, msg.sender, msg.value, 0);\n    }\n\n    /**\n     * @dev Accept a given trade (+ potentially escrow tokens).\n     * @param index Index of the trade to be accepted.\n     * @param sender Message sender\n     * @param ethValue Value sent (only used for ETH)\n     * @param erc1400TokenValue Value sent (only used for ERC1400)\n     */\n    function _acceptTrade(\n        uint256 index,\n        address sender,\n        uint256 ethValue,\n        uint256 erc1400TokenValue\n    ) internal {\n        Trade storage trade = _trades[index];\n        require(trade.state == State.Pending, \"Trade is not pending\");\n\n        address selectedHolder;\n        if (sender == trade.holder1) {\n            selectedHolder = trade.holder1;\n        } else if (sender == trade.holder2) {\n            selectedHolder = trade.holder2;\n        } else if (trade.holder2 == address(0)) {\n            trade.holder2 = sender;\n            selectedHolder = trade.holder2;\n        } else {\n            revert(\"Only registered holders can accept a trade\");\n        }\n\n        bytes memory selectedTokenData = (selectedHolder == trade.holder1)\n            ? trade.tokenData1\n            : trade.tokenData2;\n\n        (\n            address tokenAddress,\n            uint256 tokenValue,\n            bytes32 tokenId,\n            Standard tokenStandard,\n            bool accepted,\n            bool approved\n        ) = abi.decode(\n            selectedTokenData,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        require(!accepted, \"Trade already accepted by the holder\");\n\n        if (trade.tradeType == TradeType.Escrow) {\n            if (tokenStandard == Standard.ETH) {\n                require(ethValue == tokenValue, \"Amount of ETH is not correct\");\n            } else if (tokenStandard == Standard.ERC20) {\n                ERC20(tokenAddress).transferFrom(\n                    sender,\n                    address(this),\n                    tokenValue\n                );\n            } else if (tokenStandard == Standard.ERC721) {\n                ERC721(tokenAddress).transferFrom(\n                    sender,\n                    address(this),\n                    uint256(tokenId)\n                );\n            } else if (\n                tokenStandard == Standard.ERC1400 && erc1400TokenValue == 0\n            ) {\n                ERC1400(tokenAddress).operatorTransferByPartition(\n                    tokenId,\n                    sender,\n                    address(this),\n                    tokenValue,\n                    abi.encodePacked(BYPASS_ACTION_FLAG),\n                    abi.encodePacked(BYPASS_ACTION_FLAG)\n                );\n            } else if (\n                tokenStandard == Standard.ERC1400 && erc1400TokenValue != 0\n            ) {\n                require(\n                    erc1400TokenValue == tokenValue,\n                    \"Amount of ERC1400 tokens is not correct\"\n                );\n            } else {\n                // OffChain\n            }\n        } else {\n            // trade.tradeType == TradeType.Swap\n            require(\n                _allowanceIsProvided(sender, selectedTokenData),\n                \"Allowance needs to be provided in token smart contract first\"\n            );\n        }\n\n        bytes memory newTokenData = abi.encode(\n            tokenAddress,\n            tokenValue,\n            tokenId,\n            tokenStandard,\n            true,\n            approved\n        );\n        if (selectedHolder == trade.holder1) {\n            trade.tokenData1 = newTokenData;\n        } else {\n            trade.tokenData2 = newTokenData;\n        }\n\n        if (\n            trade.executer == address(0) &&\n            _tradeisAccepted(index) &&\n            _tradeisApproved(index)\n        ) {\n            _executeTrade(index);\n        }\n    }\n\n    /**\n     * @dev Verify if a trade has been accepted by the token holders.\n     *\n     * The trade needs to be accepted by both parties (token holders) before it gets executed.\n     *\n     * @param index Index of the trade to be accepted.\n     */\n    function _tradeisAccepted(uint256 index) internal view returns (bool) {\n        Trade storage trade = _trades[index];\n\n        (, , , , bool accepted1, ) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (, , , , bool accepted2, ) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        if (trade.tradeType == TradeType.Swap && trade.state == State.Pending) {\n            if (!_allowanceIsProvided(trade.holder1, trade.tokenData1)) {\n                return false;\n            }\n            if (!_allowanceIsProvided(trade.holder2, trade.tokenData2)) {\n                return false;\n            }\n        }\n\n        return (accepted1 && accepted2);\n    }\n\n    /**\n     * @dev Verify if a token allowance has been provided in token smart contract.\n     *\n     * @param sender Address of the sender.\n     * @param tokenData Encoded pack of variables for the token (address, amount, id/partition, standard, accepted, approved).\n     */\n    function _allowanceIsProvided(address sender, bytes memory tokenData)\n        internal\n        view\n        returns (bool)\n    {\n        (\n            address tokenAddress,\n            uint256 tokenValue,\n            bytes32 tokenId,\n            Standard tokenStandard,\n            ,\n\n        ) = abi.decode(\n            tokenData,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        if (tokenStandard == Standard.ERC20) {\n            return (ERC20(tokenAddress).allowance(sender, address(this)) >=\n                tokenValue);\n        } else if (tokenStandard == Standard.ERC721) {\n            return (ERC721(tokenAddress).getApproved(uint256(tokenId)) ==\n                address(this));\n        } else if (tokenStandard == Standard.ERC1400) {\n            return (ERC1400(tokenAddress).allowanceByPartition(\n                tokenId,\n                sender,\n                address(this)\n            ) >= tokenValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Approve a trade (if the tokens involved in the trade are controlled)\n     *\n     * This function can only be called by a token controller of one of the tokens involved in the trade.\n     *\n     * Indeed, when a token smart contract is controlled by an owner, the owner can decide to open the\n     * secondary market by:\n     *  - Allowlisting the DVP smart contract\n     *  - Setting \"token controllers\" in the DVP smart contract, in order to approve all the trades made with his token\n     *\n     * @param index Index of the trade to be executed.\n     * @param approved 'true' if trade is approved, 'false' if not.\n     */\n    function approveTrade(uint256 index, bool approved) external {\n        Trade storage trade = _trades[index];\n        require(trade.state == State.Pending, \"Trade is not pending\");\n\n        (address tokenAddress1, , , , , ) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (address tokenAddress2, , , , , ) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        require(\n            _isTokenController[tokenAddress1][msg.sender] ||\n                _isTokenController[tokenAddress2][msg.sender],\n            \"Only token controllers of involved tokens can approve a trade\"\n        );\n\n        if (_isTokenController[tokenAddress1][msg.sender]) {\n            (\n                ,\n                uint256 tokenValue1,\n                bytes32 tokenId1,\n                Standard tokenStandard1,\n                bool accepted1,\n\n            ) = abi.decode(\n                trade.tokenData1,\n                (address, uint256, bytes32, Standard, bool, bool)\n            );\n            trade.tokenData1 = abi.encode(\n                tokenAddress1,\n                tokenValue1,\n                tokenId1,\n                tokenStandard1,\n                accepted1,\n                approved\n            );\n        }\n\n        if (_isTokenController[tokenAddress2][msg.sender]) {\n            (\n                ,\n                uint256 tokenValue2,\n                bytes32 tokenId2,\n                Standard tokenStandard2,\n                bool accepted2,\n\n            ) = abi.decode(\n                trade.tokenData2,\n                (address, uint256, bytes32, Standard, bool, bool)\n            );\n            trade.tokenData2 = abi.encode(\n                tokenAddress2,\n                tokenValue2,\n                tokenId2,\n                tokenStandard2,\n                accepted2,\n                approved\n            );\n        }\n\n        if (\n            trade.executer == address(0) &&\n            _tradeisAccepted(index) &&\n            _tradeisApproved(index)\n        ) {\n            _executeTrade(index);\n        }\n    }\n\n    /**\n     * @dev Verify if a trade has been approved by the token controllers.\n     *\n     * In case a given token has token controllers, those need to validate the trade before it gets executed.\n     *\n     * @param index Index of the trade to be approved.\n     */\n    function _tradeisApproved(uint256 index) internal view returns (bool) {\n        Trade storage trade = _trades[index];\n\n        (address tokenAddress1, , , , , bool approved1) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (address tokenAddress2, , , , , bool approved2) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        if (_tokenControllers[tokenAddress1].length != 0 && !approved1) {\n            return false;\n        }\n\n        if (_tokenControllers[tokenAddress2].length != 0 && !approved2) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required).\n     *\n     * This function can only be called by the executer specified at trade creation.\n     * If no executer is specified, the trade can be launched by anyone.\n     *\n     * @param index Index of the trade to be executed.\n     */\n    function executeTrade(uint256 index) external {\n        Trade storage trade = _trades[index];\n        require(trade.state == State.Pending, \"Trade is not pending\");\n\n        if (trade.executer != address(0)) {\n            require(\n                msg.sender == trade.executer,\n                \"Trade can only be executed by executer defined at trade creation\"\n            );\n        }\n\n        require(\n            _tradeisAccepted(index),\n            \"Trade has not been accepted by all token holders yet\"\n        );\n\n        require(\n            _tradeisApproved(index),\n            \"Trade has not been approved by all token controllers yet\"\n        );\n\n        _executeTrade(index);\n    }\n\n    /**\n     * @dev Execute a trade in the DVP contract if possible (e.g. if tokens have been esccrowed, in case it is required).\n     * @param index Index of the trade to be executed.\n     */\n    function _executeTrade(uint256 index) internal {\n        Trade storage trade = _trades[index];\n\n        uint256 price = _getPrice(index);\n\n        (, uint256 tokenValue1, , , , ) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (, uint256 tokenValue2, , , , ) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        if (price == tokenValue2) {\n            _transferUsersTokens(index, Holder.Holder1, tokenValue1, false);\n            _transferUsersTokens(index, Holder.Holder2, tokenValue2, false);\n        } else {\n            require(\n                price <= tokenValue2,\n                \"Price is higher than amount escrowed/authorized\"\n            );\n            _transferUsersTokens(index, Holder.Holder1, tokenValue1, false);\n            _transferUsersTokens(index, Holder.Holder2, price, false);\n            if (trade.tradeType == TradeType.Escrow) {\n                _transferUsersTokens(\n                    index,\n                    Holder.Holder2,\n                    tokenValue2 - price,\n                    true\n                );\n            }\n        }\n        trade.state = State.Executed;\n    }\n\n    /**\n     * @dev Force a trade execution in the DVP contract by transferring tokens back to their target recipients.\n     * @param index Index of the trade to be forced.\n     */\n    function forceTrade(uint256 index) external {\n        Trade storage trade = _trades[index];\n        require(trade.state == State.Pending, \"Trade is not pending\");\n\n        (address tokenAddress1, uint256 tokenValue1, , , bool accepted1, ) = abi\n            .decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (address tokenAddress2, uint256 tokenValue2, , , bool accepted2, ) = abi\n            .decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        require(!(accepted1 && accepted2), \"executeTrade can be called\");\n        require(\n            _tokenControllers[tokenAddress1].length == 0 &&\n                _tokenControllers[tokenAddress2].length == 0,\n            \"Trade can not be forced if tokens have controllers\"\n        );\n\n        if (trade.executer != address(0)) {\n            require(\n                msg.sender == trade.executer,\n                \"Sender is not allowed to force trade (0)\"\n            );\n        } else if (accepted1) {\n            require(\n                msg.sender == trade.holder1,\n                \"Sender is not allowed to force trade (1)\"\n            );\n        } else if (accepted2) {\n            require(\n                msg.sender == trade.holder2,\n                \"Sender is not allowed to force trade (2)\"\n            );\n        } else {\n            revert(\"Trade can't be forced as tokens are not available so far\");\n        }\n\n        if (accepted1) {\n            _transferUsersTokens(index, Holder.Holder1, tokenValue1, false);\n        }\n\n        if (accepted2) {\n            _transferUsersTokens(index, Holder.Holder2, tokenValue2, false);\n        }\n\n        trade.state = State.Forced;\n    }\n\n    /**\n     * @dev Cancel a trade execution in the DVP contract by transferring tokens back to their initial owners.\n     * @param index Index of the trade to be cancelled.\n     */\n    function cancelTrade(uint256 index) external {\n        Trade storage trade = _trades[index];\n        require(trade.state == State.Pending, \"Trade is not pending\");\n\n        (, uint256 tokenValue1, , , bool accepted1, ) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (, uint256 tokenValue2, , , bool accepted2, ) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        if (accepted1 && accepted2) {\n            require(\n                msg.sender == trade.executer ||\n                    (block.timestamp >= trade.expirationDate &&\n                        (msg.sender == trade.holder1 ||\n                            msg.sender == trade.holder2)),\n                \"Sender is not allowed to cancel trade (0)\"\n            );\n            if (trade.tradeType == TradeType.Escrow) {\n                _transferUsersTokens(index, Holder.Holder1, tokenValue1, true);\n                _transferUsersTokens(index, Holder.Holder2, tokenValue2, true);\n            }\n        } else if (accepted1) {\n            require(\n                msg.sender == trade.executer ||\n                    (block.timestamp >= trade.expirationDate &&\n                        msg.sender == trade.holder1),\n                \"Sender is not allowed to cancel trade (1)\"\n            );\n            if (trade.tradeType == TradeType.Escrow) {\n                _transferUsersTokens(index, Holder.Holder1, tokenValue1, true);\n            }\n        } else if (accepted2) {\n            require(\n                msg.sender == trade.executer ||\n                    (block.timestamp >= trade.expirationDate &&\n                        msg.sender == trade.holder2),\n                \"Sender is not allowed to cancel trade (2)\"\n            );\n            if (trade.tradeType == TradeType.Escrow) {\n                _transferUsersTokens(index, Holder.Holder2, tokenValue2, true);\n            }\n        } else {\n            require(\n                msg.sender == trade.executer ||\n                    msg.sender == trade.holder1 ||\n                    msg.sender == trade.holder2,\n                \"Sender is not allowed to cancel trade (3)\"\n            );\n        }\n\n        trade.state = State.Cancelled;\n    }\n\n    /**\n     * @dev Internal function to transfer tokens to their recipient by taking the token standard into account.\n     * @param index Index of the trade the token transfer is execcuted for.\n     * @param holder Sender of the tokens (currently owning the tokens).\n     * @param value Amount of tokens to send.\n     * @param revertTransfer If set to true + trade has been accepted, tokens need to be sent back to their initial owners instead of sent to the target recipient.\n     */\n    function _transferUsersTokens(\n        uint256 index,\n        Holder holder,\n        uint256 value,\n        bool revertTransfer\n    ) internal {\n        Trade storage trade = _trades[index];\n\n        address sender = (holder == Holder.Holder1)\n            ? trade.holder1\n            : trade.holder2;\n        address recipient = (holder == Holder.Holder1)\n            ? trade.holder2\n            : trade.holder1;\n        bytes memory senderTokenData = (holder == Holder.Holder1)\n            ? trade.tokenData1\n            : trade.tokenData2;\n\n        (\n            address tokenAddress,\n            ,\n            bytes32 tokenId,\n            Standard tokenStandard,\n            ,\n\n        ) = abi.decode(\n            senderTokenData,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        address currentHolder = sender;\n        if (trade.tradeType == TradeType.Escrow) {\n            currentHolder = address(this);\n        }\n\n        if (revertTransfer) {\n            recipient = sender;\n        } else {\n            require(\n                block.timestamp <= trade.expirationDate,\n                \"Expiration date is past\"\n            );\n        }\n\n        if (tokenStandard == Standard.ETH) {\n            address payable payableRecipient = address(uint160(recipient));\n            payableRecipient.transfer(value);\n        } else if (tokenStandard == Standard.ERC20) {\n            if (currentHolder == address(this)) {\n                ERC20(tokenAddress).transfer(recipient, value);\n            } else {\n                ERC20(tokenAddress).transferFrom(\n                    currentHolder,\n                    recipient,\n                    value\n                );\n            }\n        } else if (tokenStandard == Standard.ERC721) {\n            ERC721(tokenAddress).transferFrom(\n                currentHolder,\n                recipient,\n                uint256(tokenId)\n            );\n        } else if (tokenStandard == Standard.ERC1400) {\n            ERC1400(tokenAddress).operatorTransferByPartition(\n                tokenId,\n                currentHolder,\n                recipient,\n                value,\n                \"\",\n                \"\"\n            );\n        } else {\n            // OffChain\n        }\n    }\n\n    /**\n     * @dev Indicate whether or not the DVP contract can receive the tokens or not.\n     *\n     * By convention, the 32 first bytes of a token transfer to the DVP smart contract contain a flag.\n     *\n     *  - When tokens are transferred to DVP contract to propose a new trade. The 'data' field starts with the\n     *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *  In this case the data structure is the the following:\n     *  <tradeFlag (32 bytes)><recipient address (32 bytes)><executer address (32 bytes)><expiration date (32 bytes)><requested token data (4 * 32 bytes)>\n     *\n     *  - When tokens are transferred to DVP contract to accept an existing trade. The 'data' field starts with the\n     *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *  In this case the data structure is the the following:\n     *  <tradeFlag (32 bytes)><request index (32 bytes)>\n     *\n     * If the 'data' doesn't start with one of those flags, the DVP contract won't accept the token transfer.\n     *\n     * @param data Information attached to the DVP transfer.\n     * @param operatorData Information attached to the DVP transfer, by the operator.\n     * @return 'true' if the DVP contract can receive the tokens, 'false' if not.\n     */\n    function _canReceive(bytes memory data, bytes memory operatorData)\n        internal\n        pure\n        returns (bool)\n    {\n        if (operatorData.length == 0) {\n            // The reason for this check is to avoid a certificate gets interpreted as a flag by mistake\n            return false;\n        }\n\n        bytes32 flag = _getTradeFlag(data);\n        if (data.length == 256 && flag == TRADE_PROPOSAL_FLAG) {\n            return true;\n        } else if (data.length == 64 && flag == TRADE_ACCEPTANCE_FLAG) {\n            return true;\n        } else if (data.length == 32 && flag == BYPASS_ACTION_FLAG) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Retrieve the trade flag from the 'data' field.\n     *\n     * By convention, the 32 first bytes of a token transfer to the DVP smart contract contain a flag.\n     *  - When tokens are transferred to DVP contract to propose a new trade. The 'data' field starts with the\n     *  following flag: 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *  - When tokens are transferred to DVP contract to accept an existing trade. The 'data' field starts with the\n     *  following flag: 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *\n     * @param data Concatenated information about the trade proposal.\n     * @return Trade flag.\n     */\n    function _getTradeFlag(bytes memory data)\n        internal\n        pure\n        returns (bytes32 flag)\n    {\n        assembly {\n            flag := mload(add(data, 32))\n        }\n    }\n\n    /**\n     * By convention, when tokens are transferred to DVP contract to propose a new trade, the 'data' of a token transfer has the following structure:\n     *  <tradeFlag (32 bytes)><recipient address (32 bytes)><executer address (32 bytes)><expiration date (32 bytes)><requested token data (5 * 32 bytes)>\n     *\n     * The first 32 bytes are the flag 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n     *\n     * The next 32 bytes contain the trade recipient address (or the zero address if the recipient is not chosen).\n     *\n     * The next 32 bytes contain the trade executer address (or zero if the executer is not chosen).\n     *\n     * The next 32 bytes contain the trade expiration date (or zero if the expiration date is not chosen).\n     *\n     * The next 32 bytes contain the trade requested token address (or the zero address if the recipient is not chosen).\n     * The next 32 bytes contain the trade requested token amount.\n     * The next 32 bytes contain the trade requested token id/partition (used when token standard is ERC721 or ERC1400).\n     * The next 32 bytes contain the trade requested token standard (OffChain, ERC20, ERC721, ERC1400, ETH).\n     * The next 32 bytes contain a boolean precising wether trade has been accepted by token holder or not.\n     * The next 32 bytes contain a boolean precising wether trade has been approved by token controller or not.\n     *\n     * Example input for recipient address '0xb5747835141b46f7C472393B31F8F5A57F74A44f', expiration date '1576348418',\n     * trade executer address '0x32F54098916ceb5f57a117dA9554175Fe25611bA', requested token address '0xC6F0410A667a5BEA528d6bc9efBe10270089Bb11',\n     * requested token amount '5', requested token id/partition '37252', and requested token type 'ERC1400', accepted and approved:\n     * 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc000000000000000000000000b5747835141b46f7C472393B31F8F5A57F74A44f\n     * 000000000000000000000000000000000000000000000000000000157634841800000000000000000000000032F54098916ceb5f57a117dA9554175Fe25611bA\n     * 000000000000000000000000C6F0410A667a5BEA528d6bc9efBe10270089Bb110000000000000000000000000000000000000000000000000000000000000005\n     * 000000000000000000000000000000000000000000000000000000000037252000000000000000000000000000000000000000000000000000000000000002\n     * 000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001\n     */\n\n    /**\n     * @dev Retrieve the recipient from the 'data' field.\n     *\n     * @param data Concatenated information about the trade proposal.\n     * @return Trade recipient address.\n     */\n    function _getTradeRecipient(bytes memory data)\n        internal\n        pure\n        returns (address recipient)\n    {\n        assembly {\n            recipient := mload(add(data, 64))\n        }\n    }\n\n    /**\n     * @dev Retrieve the trade executer address from the 'data' field.\n     *\n     * @param data Concatenated information about the trade proposal.\n     * @return Trade executer address.\n     */\n    function _getTradeExecuter(bytes memory data)\n        internal\n        pure\n        returns (address executer)\n    {\n        assembly {\n            executer := mload(add(data, 96))\n        }\n    }\n\n    /**\n     * @dev Retrieve the expiration date from the 'data' field.\n     *\n     * @param data Concatenated information about the trade proposal.\n     * @return Trade expiration date.\n     */\n    function _getTradeExpirationDate(bytes memory data)\n        internal\n        pure\n        returns (uint256 expirationDate)\n    {\n        assembly {\n            expirationDate := mload(add(data, 128))\n        }\n    }\n\n    /**\n     * @dev Retrieve the tokenData from the 'data' field.\n     *\n     * @param data Concatenated information about the trade proposal.\n     * @return Trade token data < 1: address > < 2: amount > < 3: id/partition > < 4: standard > < 5: accepted > < 6: approved >.\n     */\n    function _getTradeTokenData(bytes memory data)\n        internal\n        pure\n        returns (bytes memory tokenData)\n    {\n        address tokenAddress;\n        uint256 tokenAmount;\n        bytes32 tokenId;\n        Standard tokenStandard;\n        assembly {\n            tokenAddress := mload(add(data, 160))\n            tokenAmount := mload(add(data, 192))\n            tokenId := mload(add(data, 224))\n            tokenStandard := mload(add(data, 256))\n        }\n        tokenData = abi.encode(\n            tokenAddress,\n            tokenAmount,\n            tokenId,\n            tokenStandard,\n            false,\n            false\n        );\n    }\n\n    /**\n     * @dev Retrieve the trade index from the 'data' field.\n     *\n     * By convention, when tokens are transferred to DVP contract to accept an existing trade, the 'data' of a token transfer has the following structure:\n     *  <tradeFlag (32 bytes)><index uint256 (32 bytes)>\n     *\n     * The first 32 bytes are the flag 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\n     *\n     * The next 32 bytes contain the trade index.\n     *\n     * Example input for trade index #2985:\n     * 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd0000000000000000000000000000000000000000000000000000000000002985\n     *\n     * @param data Concatenated information about the trade validation.\n     * @return Trade index.\n     */\n    function _getTradeIndex(bytes memory data)\n        internal\n        pure\n        returns (uint256 index)\n    {\n        assembly {\n            index := mload(add(data, 64))\n        }\n    }\n\n    /**************************** TRADE EXECUTERS *******************************/\n\n    /**\n     * @dev Renounce ownership of the contract.\n     */\n    function renounceOwnership() public onlyOwner {\n        Ownable.renounceOwnership();\n        _ownedContract = false;\n    }\n\n    /**\n     * @dev Get the list of trade executers as defined by the DVP contract.\n     * @return List of addresses of all the trade executers.\n     */\n    function tradeExecuters() external view returns (address[] memory) {\n        return _tradeExecuters;\n    }\n\n    /**\n     * @dev Set list of trade executers for the DVP contract.\n     * @param operators Trade executers addresses.\n     */\n    function setTradeExecuters(address[] calldata operators)\n        external\n        onlyOwner\n    {\n        require(_ownedContract, \"DVP contract is not owned\");\n        _setTradeExecuters(operators);\n    }\n\n    /**\n     * @dev Set list of trade executers for the DVP contract.\n     * @param operators Trade executers addresses.\n     */\n    function _setTradeExecuters(address[] memory operators) internal {\n        for (uint256 i = 0; i < _tradeExecuters.length; i++) {\n            _isTradeExecuter[_tradeExecuters[i]] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isTradeExecuter[operators[j]] = true;\n        }\n        _tradeExecuters = operators;\n    }\n\n    /************************** TOKEN CONTROLLERS *******************************/\n\n    /**\n     * @dev Get the list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @return List of addresses of all the token controllers for a given token.\n     */\n    function tokenControllers(address tokenAddress)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _tokenControllers[tokenAddress];\n    }\n\n    /**\n     * @dev Set list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @param operators Operators addresses.\n     */\n    function setTokenControllers(\n        address tokenAddress,\n        address[] calldata operators\n    ) external onlyTokenController(tokenAddress) {\n        _setTokenControllers(tokenAddress, operators);\n    }\n\n    /**\n     * @dev Set list of token controllers for a given token.\n     * @param tokenAddress Token address.\n     * @param operators Operators addresses.\n     */\n    function _setTokenControllers(\n        address tokenAddress,\n        address[] memory operators\n    ) internal {\n        for (uint256 i = 0; i < _tokenControllers[tokenAddress].length; i++) {\n            _isTokenController[tokenAddress][_tokenControllers[tokenAddress][i]] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isTokenController[tokenAddress][operators[j]] = true;\n        }\n        _tokenControllers[tokenAddress] = operators;\n    }\n\n    /************************** TOKEN PRICE ORACLES *******************************/\n\n    /**\n     * @dev Get the list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @return List of addresses of all the price oracles for a given token.\n     */\n    function priceOracles(address tokenAddress)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _priceOracles[tokenAddress];\n    }\n\n    /**\n     * @dev Set list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @param oracles Oracles addresses.\n     */\n    function setPriceOracles(address tokenAddress, address[] calldata oracles)\n        external\n        onlyPriceOracle(tokenAddress)\n    {\n        _setPriceOracles(tokenAddress, oracles);\n    }\n\n    /**\n     * @dev Set list of price oracles for a given token.\n     * @param tokenAddress Token address.\n     * @param oracles Oracles addresses.\n     */\n    function _setPriceOracles(address tokenAddress, address[] memory oracles)\n        internal\n    {\n        for (uint256 i = 0; i < _priceOracles[tokenAddress].length; i++) {\n            _isPriceOracle[tokenAddress][_priceOracles[tokenAddress][i]] = false;\n        }\n        for (uint256 j = 0; j < oracles.length; j++) {\n            _isPriceOracle[tokenAddress][oracles[j]] = true;\n        }\n        _priceOracles[tokenAddress] = oracles;\n    }\n\n    /**\n     * @dev Check if address is oracle of a given token.\n     * @param tokenAddress Token address.\n     * @param oracle Oracle address.\n     * @return 'true' if the address is oracle of the given token.\n     */\n    function _checkPriceOracle(address tokenAddress, address oracle)\n        internal\n        view\n        returns (bool)\n    {\n        return (_isPriceOracle[tokenAddress][oracle] ||\n            oracle == Ownable(tokenAddress).owner());\n    }\n\n    /****************************** DVP PRICES *********************************/\n\n    /**\n     * @dev Get price of the token.\n     * @param tokenAddress1 Address of the token to be priced.\n     * @param tokenAddress2 Address of the token to pay for token1.\n     */\n    function getPriceOwnership(address tokenAddress1, address tokenAddress2)\n        external\n        view\n        returns (bool)\n    {\n        return _priceOwnership[tokenAddress1][tokenAddress2];\n    }\n\n    /**\n     * @dev Take ownership for setting the price of a token.\n     * @param tokenAddress1 Address of the token to be priced.\n     * @param tokenAddress2 Address of the token to pay for token1.\n     */\n    function setPriceOwnership(\n        address tokenAddress1,\n        address tokenAddress2,\n        bool priceOwnership\n    ) external onlyPriceOracle(tokenAddress1) {\n        _priceOwnership[tokenAddress1][tokenAddress2] = priceOwnership;\n    }\n\n    /**\n     * @dev Get date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n     * @param tokenAddress Token address.\n     */\n    function variablePriceStartDate(address tokenAddress)\n        external\n        view\n        returns (uint256)\n    {\n        return _variablePriceStartDate[tokenAddress];\n    }\n\n    /**\n     * @dev Set date after which the token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n     * @param tokenAddress Token address.\n     * @param startDate Date after which token price can potentially be set by an oracle (0 if price can not be set by an oracle).\n     */\n    function setVariablePriceStartDate(address tokenAddress, uint256 startDate)\n        external\n        onlyPriceOracle(tokenAddress)\n    {\n        require(\n            (startDate > block.timestamp + SECONDS_IN_WEEK) || startDate == 0,\n            \"Start date needs to be set at least a week before\"\n        );\n        _variablePriceStartDate[tokenAddress] = startDate;\n    }\n\n    /**\n     * @dev Get price of the token.\n     * @param tokenAddress1 Address of the token to be priced.\n     * @param tokenAddress2 Address of the token to pay for token1.\n     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).\n     * @param tokenId1 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).\n     */\n    function getTokenPrice(\n        address tokenAddress1,\n        address tokenAddress2,\n        bytes32 tokenId1,\n        bytes32 tokenId2\n    ) external view returns (uint256) {\n        return\n            _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2];\n    }\n\n    /**\n     * @dev Set price of a token.\n     * @param tokenAddress1 Address of the token to be priced.\n     * @param tokenAddress2 Address of the token to pay for token1.\n     * @param tokenId1 ID/partition of the token1 (set to 0 bytes32 if price is set for all IDs/partitions).\n     * @param tokenId2 ID/partition of the token2 (set to 0 bytes32 if price is set for all IDs/partitions).\n     * @param newPrice New price of the token.\n     */\n    function setTokenPrice(\n        address tokenAddress1,\n        address tokenAddress2,\n        bytes32 tokenId1,\n        bytes32 tokenId2,\n        uint256 newPrice\n    ) external {\n        require(\n            !(_priceOwnership[tokenAddress1][tokenAddress2] &&\n                _priceOwnership[tokenAddress2][tokenAddress1]),\n            \"Competition on price ownership\"\n        );\n\n        if (_priceOwnership[tokenAddress1][tokenAddress2]) {\n            require(\n                _checkPriceOracle(tokenAddress1, msg.sender),\n                \"Price setter is not an oracle for this token (1)\"\n            );\n        } else if (_priceOwnership[tokenAddress2][tokenAddress1]) {\n            require(\n                _checkPriceOracle(tokenAddress2, msg.sender),\n                \"Price setter is not an oracle for this token (2)\"\n            );\n        } else {\n            revert(\"No price ownership\");\n        }\n\n        _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2] = newPrice;\n    }\n\n    /**\n     * @dev Get amount of token2 to pay to acquire the token1.\n     * @param index Index of the DVP request.\n     */\n    function getPrice(uint256 index) external view returns (uint256) {\n        return _getPrice(index);\n    }\n\n    /**\n     * @dev Get amount of token2 to pay to acquire the token1.\n     * @param index Index of the DVP request.\n     */\n    function _getPrice(uint256 index) internal view returns (uint256) {\n        Trade storage trade = _trades[index];\n        (\n            address tokenAddress1,\n            uint256 tokenValue1,\n            bytes32 tokenId1,\n            ,\n            ,\n\n        ) = abi.decode(\n            trade.tokenData1,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n        (\n            address tokenAddress2,\n            uint256 tokenValue2,\n            bytes32 tokenId2,\n            ,\n            ,\n\n        ) = abi.decode(\n            trade.tokenData2,\n            (address, uint256, bytes32, Standard, bool, bool)\n        );\n\n        require(\n            !(_priceOwnership[tokenAddress1][tokenAddress2] &&\n                _priceOwnership[tokenAddress2][tokenAddress1]),\n            \"Competition on price ownership\"\n        );\n\n        if (\n            _variablePriceStartDate[tokenAddress1] == 0 ||\n            block.timestamp < _variablePriceStartDate[tokenAddress1]\n        ) {\n            return tokenValue2;\n        }\n\n        if (\n            _priceOwnership[tokenAddress1][tokenAddress2] ||\n            _priceOwnership[tokenAddress2][tokenAddress1]\n        ) {\n            if (\n                _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2] !=\n                0\n            ) {\n                return\n                    tokenValue1.mul(\n                        _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][tokenId2]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][tokenId1] !=\n                0\n            ) {\n                return\n                    tokenValue1.div(\n                        _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][tokenId1]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][ALL_PARTITIONS] !=\n                0\n            ) {\n                return\n                    tokenValue1.mul(\n                        _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][tokenId1][ALL_PARTITIONS]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][tokenId1] !=\n                0\n            ) {\n                return\n                    tokenValue1.div(\n                        _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][tokenId1]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][tokenId2] !=\n                0\n            ) {\n                return\n                    tokenValue1.mul(\n                        _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][tokenId2]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][ALL_PARTITIONS] !=\n                0\n            ) {\n                return\n                    tokenValue1.div(\n                        _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][tokenId2][ALL_PARTITIONS]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][ALL_PARTITIONS] !=\n                0\n            ) {\n                return\n                    tokenValue1.mul(\n                        _tokenUnitPricesByPartition[tokenAddress1][tokenAddress2][ALL_PARTITIONS][ALL_PARTITIONS]\n                    );\n            } else if (\n                _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][ALL_PARTITIONS] !=\n                0\n            ) {\n                return\n                    tokenValue1.div(\n                        _tokenUnitPricesByPartition[tokenAddress2][tokenAddress1][ALL_PARTITIONS][ALL_PARTITIONS]\n                    );\n            } else {\n                return tokenValue2;\n            }\n        } else {\n            return tokenValue2;\n        }\n    }\n\n    /**************************** VIEW FUNCTIONS *******************************/\n\n    /**\n     * @dev Get the trade.\n     * @param index Index of the trade.\n     * @return Trade.\n     */\n    function getTrade(uint256 index)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            bytes memory,\n            bytes memory,\n            TradeType,\n            State\n        )\n    {\n        Trade storage trade = _trades[index];\n        return (\n            trade.holder1,\n            trade.holder2,\n            trade.executer,\n            trade.expirationDate,\n            trade.tokenData1,\n            trade.tokenData2,\n            trade.tradeType,\n            trade.state\n        );\n    }\n\n    /**\n     * @dev Get the total number of requests in the DVP contract.\n     * @return Total number of requests in the DVP contract.\n     */\n    function getNbTrades() external view returns (uint256) {\n        return _index;\n    }\n\n    /**\n     * @dev Get global acceptance status for a given a trade.\n     * @return Acceptance status.\n     */\n    function getTradeAcceptanceStatus(uint256 index)\n        external\n        view\n        returns (bool)\n    {\n        return _tradeisAccepted(index);\n    }\n\n    /**\n     * @dev Get global approval status for a given a trade.\n     * @return Approval status.\n     */\n    function getTradeApprovalStatus(uint256 index)\n        external\n        view\n        returns (bool)\n    {\n        return _tradeisApproved(index);\n    }\n}\n"
    },
    "contracts/tools/DVPHoldableLockable.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"../ERC1820//ERC1820Client.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../tokens/IERC20HoldableToken.sol\";\n\ninterface HoldableERC1400TokenExtension {\n    enum HoldStatusCode {\n        Nonexistent,\n        Ordered,\n        Executed,\n        ExecutedAndKeptOpen,\n        ReleasedByNotary,\n        ReleasedByPayee,\n        ReleasedOnExpiration\n    }\n\n    function executeHold(\n        address token,\n        bytes32 holdId,\n        uint256 value,\n        bytes32 lockPreimage\n    ) external;\n\n    function retrieveHoldData(address token, bytes32 holdId)\n        external\n        view\n        returns (\n            bytes32 partition,\n            address sender,\n            address recipient,\n            address notary,\n            uint256 value,\n            uint256 expiration,\n            bytes32 secretHash,\n            bytes32 secret,\n            HoldStatusCode status\n        );\n}\n\n/**\n * @title DVPHoldableLockable\n * @notice Facilitates the atomic settlement of ERC20 and ERC1400 Holdable Tokens.\n */\ncontract DVPHoldableLockable is ERC1820Client, ERC1820Implementer {\n    string internal constant DVP_HOLDABLE_LOCKABLE = \"DVPHoldableLockable\";\n\n    string\n        internal constant ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n    enum Standard {Undefined, HoldableERC20, HoldableERC1400}\n\n    event ExecuteHolds(\n        address indexed token1,\n        bytes32 token1HoldId,\n        address indexed token2,\n        bytes32 token2HoldId,\n        bytes32 preimage,\n        address token1Recipient,\n        address token2Recipient\n    );\n\n    /**\n    @dev Include token events so they can be parsed by Ethereum clients from the settlement transactions.\n     */\n    // Holdable\n    event ExecutedHold(bytes32 indexed holdId, bytes32 lockPreimage);\n    event ExecutedHold(\n        bytes32 indexed holdId,\n        bytes32 lockPreimage,\n        address recipient\n    );\n    // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    // ERC1400\n    event TransferByPartition(\n        bytes32 indexed fromPartition,\n        address operator,\n        address indexed from,\n        address indexed to,\n        uint256 value,\n        bytes data,\n        bytes operatorData\n    );\n    event CreateNote(\n        address indexed owner,\n        bytes32 indexed noteHash,\n        bytes metadata\n    );\n    event DestroyNote(address indexed owner, bytes32 indexed noteHash);\n\n    /**\n     * [DVP CONSTRUCTOR]\n     */\n    constructor() public {\n        ERC1820Implementer._setInterface(DVP_HOLDABLE_LOCKABLE);\n    }\n\n    /**\n     @notice Execute holds where the hold recipients are already known\n     @param token1 contract address of the first token\n     @param token1HoldId 32 byte hold identified from the first token\n     @param tokenStandard1 Standard enum indicating if the first token is HoldableERC20 or HoldableERC1400\n     @param token2 contract address of the second token\n     @param token2HoldId 32 byte hold identified from the second token\n     @param tokenStandard2 Standard enum indicating if the second token is HoldableERC20 or HoldableERC1400\n     @param preimage optional preimage of the SHA256 hash used to lock both the token holds. This can be a zero address if no lock hash was used.\n     */\n    function executeHolds(\n        address token1,\n        bytes32 token1HoldId,\n        Standard tokenStandard1,\n        address token2,\n        bytes32 token2HoldId,\n        Standard tokenStandard2,\n        bytes32 preimage\n    ) public {\n        _executeHolds(\n            token1,\n            token1HoldId,\n            tokenStandard1,\n            token2,\n            token2HoldId,\n            tokenStandard2,\n            preimage,\n            address(0),\n            address(0)\n        );\n    }\n\n    /**\n     @notice Execute holds where the hold recipients are only known at execution.\n     @param token1 contract address of the first token\n     @param token1HoldId 32 byte hold identified from the first token\n     @param tokenStandard1 Standard enum indicating if the first token is HoldableERC20 or HoldableERC1400\n     @param token2 contract address of the second token\n     @param token2HoldId 32 byte hold identified from the second token\n     @param tokenStandard2 Standard enum indicating if the second token is HoldableERC20 or HoldableERC1400\n     @param preimage optional preimage of the SHA256 hash used to lock both the token holds. This can be a zero address if no lock hash was used.\n     @param token1Recipient address of the recipient of the first tokens.\n     @param token2Recipient address of the recipient of the second tokens.\n     */\n    function executeHolds(\n        address token1,\n        bytes32 token1HoldId,\n        Standard tokenStandard1,\n        address token2,\n        bytes32 token2HoldId,\n        Standard tokenStandard2,\n        bytes32 preimage,\n        address token1Recipient,\n        address token2Recipient\n    ) public {\n        _executeHolds(\n            token1,\n            token1HoldId,\n            tokenStandard1,\n            token2,\n            token2HoldId,\n            tokenStandard2,\n            preimage,\n            token1Recipient,\n            token2Recipient\n        );\n    }\n\n    /**\n     @dev this is in a separate function to work around stack too deep problems\n     */\n    function _executeHolds(\n        address token1,\n        bytes32 token1HoldId,\n        Standard tokenStandard1,\n        address token2,\n        bytes32 token2HoldId,\n        Standard tokenStandard2,\n        bytes32 preimage,\n        address token1Recipient,\n        address token2Recipient\n    ) internal {\n        // Token 1\n        if (tokenStandard1 == Standard.HoldableERC20) {\n            _executeERC20Hold(token1, token1HoldId, preimage, token1Recipient);\n        } else if (tokenStandard1 == Standard.HoldableERC1400) {\n            _executeERC1400Hold(token1, token1HoldId, preimage);\n        } else {\n            revert(\"invalid token standard\");\n        }\n\n        // Token 2\n        if (tokenStandard2 == Standard.HoldableERC20) {\n            _executeERC20Hold(token2, token2HoldId, preimage, token2Recipient);\n        } else if (tokenStandard2 == Standard.HoldableERC1400) {\n            _executeERC1400Hold(token2, token2HoldId, preimage);\n        } else {\n            revert(\"invalid token standard\");\n        }\n\n        emit ExecuteHolds(\n            token1,\n            token1HoldId,\n            token2,\n            token2HoldId,\n            preimage,\n            token1Recipient,\n            token2Recipient\n        );\n    }\n\n    function _executeERC20Hold(\n        address token,\n        bytes32 tokenHoldId,\n        bytes32 preimage,\n        address tokenRecipient\n    ) internal {\n        require(token != address(0), \"token can not be a zero address\");\n\n        if (tokenRecipient == address(0)) {\n            IERC20HoldableToken(token).executeHold(tokenHoldId, preimage);\n        } else {\n            IERC20HoldableToken(token).executeHold(\n                tokenHoldId,\n                preimage,\n                tokenRecipient\n            );\n        }\n    }\n\n    function _executeERC1400Hold(\n        address token,\n        bytes32 tokenHoldId,\n        bytes32 preimage\n    ) internal {\n        require(token != address(0), \"token can not be a zero address\");\n\n        address tokenExtension = interfaceAddr(token, ERC1400_TOKENS_VALIDATOR);\n        require(\n            tokenExtension != address(0),\n            \"token has no holdable token extension\"\n        );\n\n        uint256 holdValue;\n        (, , , , holdValue, , , , ) = HoldableERC1400TokenExtension(\n            tokenExtension\n        )\n            .retrieveHoldData(token, tokenHoldId);\n\n        HoldableERC1400TokenExtension(tokenExtension).executeHold(\n            token,\n            tokenHoldId,\n            holdValue,\n            preimage\n        );\n    }\n}\n"
    },
    "contracts/tokens/IERC20HoldableToken.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\n/**\n * @title Holdable ERC20 Token Interface.\n * @dev like approve except the tokens can't be spent by the sender while they are on hold.\n */\ninterface IERC20HoldableToken {\n    enum HoldStatusCode {Nonexistent, Held, Executed, Released}\n\n    event NewHold(\n        bytes32 indexed holdId,\n        address indexed recipient,\n        address indexed notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    );\n    event ExecutedHold(\n        bytes32 indexed holdId,\n        bytes32 lockPreimage,\n        address recipient\n    );\n    event ReleaseHold(bytes32 indexed holdId, address sender);\n\n    /**\n     @notice Called by the sender to hold some tokens for a recipient that the sender can not release back to themself until after the expiration date.\n     @param recipient optional account the tokens will be transferred to on execution. If a zero address, the recipient must be specified on execution of the hold.\n     @param notary account that can execute the hold. Typically the recipient but can be a third party or a smart contact.\n     @param amount of tokens to be transferred to the recipient on execution. Must be a non zero amount.\n     @param expirationDateTime UNIX epoch seconds the held amount can be released back to the sender by the sender. Past dates are allowed.\n     @param lockHash optional keccak256 hash of a lock preimage. An empty hash will not enforce the hash lock when the hold is executed.\n     @return a unique identifier for the hold.\n     */\n    function hold(\n        address recipient,\n        address notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    ) external returns (bytes32 holdId);\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the set at the hold recipient if there is no hash lock.\n     @param holdId a unique identifier for the hold.\n     */\n    function executeHold(bytes32 holdId) external;\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient that was set at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     */\n    function executeHold(bytes32 holdId, bytes32 lockPreimage) external;\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient if no recipient was specified at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     @param recipient the account the tokens will be transferred to on execution.\n     */\n    function executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) external;\n\n    /**\n     @notice Called by the notary at any time or the sender after the expiration date to release the held tokens back to the sender.\n     @param holdId a unique identifier for the hold.\n     */\n    function releaseHold(bytes32 holdId) external;\n\n    /**\n     @notice Amount of tokens owned by an account that are available for transfer. That is, the gross balance less any held tokens.\n     @param account owner of the tokensß\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     @notice Amount of tokens owned by an account that are held pending execution or release.\n     @param account owner of the tokens\n     */\n    function holdBalanceOf(address account) external view returns (uint256);\n\n    /**\n     @notice Total amount of tokens owned by an account including all the held tokens pending execution or release.\n     @param account owner of the tokens\n     */\n    function grossBalanceOf(address account) external view returns (uint256);\n\n    function totalSupplyOnHold() external view returns (uint256);\n\n    /**\n     @param holdId a unique identifier for the hold.\n     @return hold status code.\n     */\n    function holdStatus(bytes32 holdId) external view returns (HoldStatusCode);\n}\n"
    },
    "contracts/tokens/ERC20HoldableToken.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"./ERC20Token.sol\";\nimport \"./IERC20HoldableToken.sol\";\n\n/**\n * @title ERC20HoldableToken\n * @notice A hold is like an approve where held tokens can not be spent by the token holder until after an hold expiration period.\n    The hold can be executed by a notary, which can be the recipient of the tokens, a third party or a smart contract.\n    The notary can execute the hold before or after the expiration period.\n    Additionally, a hash lock at be applied which requires the notary of the hold to present the hash preimage to execute the hold.\n    Held tokens can be released by the notary at any time or by the token holder after the expiration period.\n    A recipient does not have to get set at the time of the hold, which means it will have to be specified when the hold is executed.\n */\ncontract ERC20HoldableToken is IERC20HoldableToken, ERC20Token {\n    struct HoldData {\n        address sender;\n        address recipient;\n        address notary;\n        uint256 amount;\n        uint256 expirationDateTime;\n        bytes32 lockHash;\n        HoldStatusCode status;\n    }\n\n    // mapping of accounts to hold data\n    mapping(bytes32 => HoldData) internal holds;\n    // mapping of accounts and their total amount on hold\n    mapping(address => uint256) internal accountHoldBalances;\n    uint256 public totalSupplyOnHold;\n\n    modifier isHeld(bytes32 holdId) {\n        require(\n            holds[holdId].status == HoldStatusCode.Held,\n            \"Hold is not in Held status\"\n        );\n        _;\n    }\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public ERC20Token(name, symbol, decimals) {}\n\n    /**\n     @notice Called by the sender to hold some tokens for a recipient that the sender can not release back to themself until after the expiration date.\n     @param recipient optional account the tokens will be transferred to on execution. If a zero address, the recipient must be specified on execution of the hold.\n     @param notary account that can execute the hold. Typically the recipient but can be a third party or a smart contact.\n     @param amount of tokens to be transferred to the recipient on execution. Must be a non zero amount.\n     @param expirationDateTime UNIX epoch seconds the held amount can be released back to the sender by the sender. Past dates are allowed.\n     @param lockHash optional keccak256 hash of a lock preimage. An empty hash will not enforce the hash lock when the hold is executed.\n     @return a unique identifier for the hold.\n     */\n    function hold(\n        address recipient,\n        address notary,\n        uint256 amount,\n        uint256 expirationDateTime,\n        bytes32 lockHash\n    ) public returns (bytes32 holdId) {\n        require(\n            notary != address(0),\n            \"hold: notary must not be a zero address\"\n        );\n        require(amount != 0, \"hold: amount must be greater than zero\");\n        require(\n            this.balanceOf(msg.sender) >= amount,\n            \"hold: amount exceeds available balance\"\n        );\n        holdId = keccak256(\n            abi.encodePacked(\n                recipient,\n                notary,\n                amount,\n                expirationDateTime,\n                lockHash\n            )\n        );\n        require(\n            holds[holdId].status == HoldStatusCode.Nonexistent,\n            \"hold: id already exists\"\n        );\n        holds[holdId] = HoldData(\n            msg.sender,\n            recipient,\n            notary,\n            amount,\n            expirationDateTime,\n            lockHash,\n            HoldStatusCode.Held\n        );\n        accountHoldBalances[msg.sender] = accountHoldBalances[msg.sender].add(\n            amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.add(amount);\n\n        emit NewHold(\n            holdId,\n            recipient,\n            notary,\n            amount,\n            expirationDateTime,\n            lockHash\n        );\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the set at the hold recipient if there is no hash lock.\n     @param holdId a unique identifier for the hold.\n     */\n    function executeHold(bytes32 holdId) public {\n        require(\n            holds[holdId].recipient != address(0),\n            \"executeHold: must pass the recipient on execution as the recipient was not set on hold\"\n        );\n        require(\n            holds[holdId].lockHash == bytes32(0),\n            \"executeHold: need preimage if the hold has a lock hash\"\n        );\n\n        _executeHold(holdId, \"\", holds[holdId].recipient);\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient that was set at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     */\n    function executeHold(bytes32 holdId, bytes32 lockPreimage) public {\n        require(\n            holds[holdId].recipient != address(0),\n            \"executeHold: must pass the recipient on execution as the recipient was not set on hold\"\n        );\n        if (holds[holdId].lockHash != bytes32(0)) {\n            require(\n                holds[holdId].lockHash ==\n                    sha256(abi.encodePacked(lockPreimage)),\n                \"executeHold: preimage hash does not match lock hash\"\n            );\n        }\n\n        _executeHold(holdId, lockPreimage, holds[holdId].recipient);\n    }\n\n    /**\n     @notice Called by the notary to transfer the held tokens to the recipient if no recipient was specified at the hold.\n     @param holdId a unique identifier for the hold.\n     @param lockPreimage the image used to generate the lock hash with a keccak256 hash\n     @param recipient the account the tokens will be transferred to on execution.\n     */\n    function executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) public {\n        require(\n            holds[holdId].recipient == address(0),\n            \"executeHold: can not set a recipient on execution as it was set on hold\"\n        );\n        require(\n            recipient != address(0),\n            \"executeHold: recipient must not be a zero address\"\n        );\n        if (holds[holdId].lockHash != bytes32(0)) {\n            require(\n                holds[holdId].lockHash ==\n                    sha256(abi.encodePacked(lockPreimage)),\n                \"executeHold: preimage hash does not match lock hash\"\n            );\n        }\n\n        holds[holdId].recipient = recipient;\n\n        _executeHold(holdId, lockPreimage, recipient);\n    }\n\n    function _executeHold(\n        bytes32 holdId,\n        bytes32 lockPreimage,\n        address recipient\n    ) internal isHeld(holdId) {\n        require(\n            holds[holdId].notary == msg.sender,\n            \"executeHold: caller must be the hold notary\"\n        );\n\n        super._transfer(holds[holdId].sender, recipient, holds[holdId].amount);\n\n        holds[holdId].status = HoldStatusCode.Executed;\n        accountHoldBalances[holds[holdId]\n            .sender] = accountHoldBalances[holds[holdId].sender].sub(\n            holds[holdId].amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.sub(holds[holdId].amount);\n\n        emit ExecutedHold(holdId, lockPreimage, recipient);\n    }\n\n    /**\n     @notice Called by the notary at any time or the sender after the expiration date to release the held tokens back to the sender.\n     @param holdId a unique identifier for the hold.\n     */\n    function releaseHold(bytes32 holdId) public isHeld(holdId) {\n        if (holds[holdId].sender == msg.sender) {\n            require(\n                now > holds[holdId].expirationDateTime,\n                \"releaseHold: can only release after the expiration date.\"\n            );\n        } else if (holds[holdId].notary != msg.sender) {\n            revert(\"releaseHold: caller must be the hold sender or notary.\");\n        }\n\n        holds[holdId].status = HoldStatusCode.Released;\n        accountHoldBalances[holds[holdId]\n            .sender] = accountHoldBalances[holds[holdId].sender].sub(\n            holds[holdId].amount\n        );\n        totalSupplyOnHold = totalSupplyOnHold.sub(holds[holdId].amount);\n\n        emit ReleaseHold(holdId, msg.sender);\n    }\n\n    /**\n     @notice Amount of tokens owned by an account that are available for transfer. That is, the gross balance less any held tokens.\n     @param account owner of the tokensß\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return super.balanceOf(account).sub(accountHoldBalances[account]);\n    }\n\n    /**\n     @notice Amount of tokens owned by an account that are held pending execution or release.\n     @param account owner of the tokens\n     */\n    function holdBalanceOf(address account) public view returns (uint256) {\n        return accountHoldBalances[account];\n    }\n\n    /**\n     @notice Total amount of tokens owned by an account including all the held tokens pending execution or release.\n     @param account owner of the tokens\n     */\n    function grossBalanceOf(address account) public view returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    /**\n     @param holdId a unique identifier for the hold.\n     @return hold status code.\n     */\n    function holdStatus(bytes32 holdId) public view returns (HoldStatusCode) {\n        return holds[holdId].status;\n    }\n\n    /**\n     @notice ERC20 transfer that checks on hold tokens can not be transferred.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(\n            this.balanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.transfer(recipient, amount);\n    }\n\n    /**\n     @notice ERC20 transferFrom that checks on hold tokens can not be transferred.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public returns (bool) {\n        require(\n            this.balanceOf(sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    /**\n     @notice ERC20 approve that checks on hold tokens can not be approved for spending by another account.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(\n            this.balanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        return super.approve(spender, amount);\n    }\n\n    /**\n     @notice ERC20 burn that checks on hold tokens can not be burnt.\n     */\n    function burn(uint256 amount) public {\n        require(\n            this.balanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        super.burn(amount);\n    }\n\n    /**\n     @notice ERC20 burnFrom that checks on hold tokens can not be burnt.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        require(\n            this.balanceOf(msg.sender) >= amount,\n            \"HoldableToken: amount exceeds available balance\"\n        );\n        super.burnFrom(account, amount);\n    }\n}\n"
    },
    "contracts/tokens/ERC20Token.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Pausable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\ncontract ERC20Token is Ownable, ERC20Mintable, ERC20Burnable, ERC20Pausable, ERC20Detailed, ERC1820Implementer {\n  string constant internal ERC20_TOKEN = \"ERC20Token\";\n\n  constructor(string memory name, string memory symbol, uint8 decimals) public ERC20Detailed(name, symbol, decimals) {\n    ERC1820Implementer._setInterface(ERC20_TOKEN);\n  }\n\n}"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The address which you want to send tokens from\n     * @param value uint256 The amount of token to be burned\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @title Pausable token\n * @dev ERC20 modified with pausable transfers.\n **/\ncontract ERC20Pausable is ERC20, Pausable {\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }\n\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/lifecycle/Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../access/roles/PauserRole.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is PauserRole {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/roles/PauserRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../Roles.sol\";\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender));\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n"
    },
    "contracts/tools/BatchTokenIssuer.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../IERC1400.sol\";\n\n/**\n * @notice Interface to the Minterrole contract\n */\ninterface IMinterRole {\n  function isMinter(address account) external view returns (bool);\n}\n\n/**\n * @title BatchTokenIssuer\n * @dev Proxy contract to issue multiple ERC1400/ERC20 tokens in a single transaction.\n */\ncontract BatchTokenIssuer is ERC1820Implementer {\n\n  string constant internal BATCH_ISSUER = \"BatchTokenIssuer\";\n\n  // Mapping from token to token minters.\n  mapping(address => address[]) internal _tokenMinters;\n\n  // Mapping from (token, operator) to token minter status.\n  mapping(address => mapping(address => bool)) internal _isTokenMinter;\n\n  /**\n   * @dev Modifier to verify if sender is a token minter.\n   */\n  modifier onlyTokenMinter(address token) {\n    require(IMinterRole(token).isMinter(msg.sender),\n      \"Sender is not a token minter.\"\n    );\n    _;\n  }\n\n  constructor() public {\n    ERC1820Implementer._setInterface(BATCH_ISSUER);\n  }\n\n  /**\n   * @dev Issue tokens for multiple addresses.\n   * @param token Address of token where the tokens need to be issued.\n   * @param partitions Name of the partitions.\n   * @param tokenHolders Addresses for which we want to issue tokens.\n   * @param values Number of tokens issued.\n   */\n  function batchIssueByPartition(\n    address token,\n    bytes32[] calldata partitions,\n    address[] calldata tokenHolders,\n    uint256[] calldata values\n  )\n    external\n    onlyTokenMinter(token)\n    returns (uint256[] memory)\n  {\n    require(partitions.length == tokenHolders.length, \"partitions and tokenHolders arrays have different lengths\");\n    require(partitions.length == values.length, \"partitions and values arrays have different lengths\");\n    \n    for (uint i = 0; i < partitions.length; i++) {\n        IERC1400(token).issueByPartition(partitions[i], tokenHolders[i], values[i], \"\");\n    }\n  }\n\n}\n"
    },
    "contracts/tools/BatchBalanceReader.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\nimport \"../IERC1400.sol\";\n\ninterface IERC1400Extended {\n    // Not a real interface but added here since 'totalSupplyByPartition' doesn't belong to IERC1400\n\n    function totalSupplyByPartition(bytes32 partition)\n        external\n        view\n        returns (uint256);\n}\n\n/**\n * @title BatchBalanceReader\n * @dev Proxy contract to read multiple ERC1400/ERC20 token balances in a single contract call.\n */\ncontract BatchBalanceReader is ERC1820Implementer {\n    string internal constant BALANCE_READER = \"BatchBalanceReader\";\n\n    constructor() public {\n        ERC1820Implementer._setInterface(BALANCE_READER);\n    }\n\n    /**\n     * @dev Get a batch of ERC1400 token balances.\n     * @param tokenHolders Addresses for which the balance is required.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @param partitions Name of the partitions.\n     * @return Balances array.\n     */\n    function balancesOfByPartition(\n        address[] calldata tokenHolders,\n        address[] calldata tokenAddresses,\n        bytes32[] calldata partitions\n    ) external view returns (uint256[] memory) {\n        uint256[] memory partitionBalances = new uint256[](\n            tokenAddresses.length * partitions.length * tokenHolders.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\n                for (uint256 k = 0; k < partitions.length; k++) {\n                    index =\n                        i *\n                        (tokenAddresses.length * partitions.length) +\n                        j *\n                        partitions.length +\n                        k;\n                    partitionBalances[index] = IERC1400(tokenAddresses[j])\n                        .balanceOfByPartition(partitions[k], tokenHolders[i]);\n                }\n            }\n        }\n\n        return partitionBalances;\n    }\n\n    /**\n     * @dev Get a batch of ERC20 token balances.\n     * @param tokenHolders Addresses for which the balance is required.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function balancesOf(\n        address[] calldata tokenHolders,\n        address[] calldata tokenAddresses\n    ) external view returns (uint256[] memory) {\n        uint256[] memory balances = new uint256[](\n            tokenHolders.length * tokenAddresses.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\n            for (uint256 j = 0; j < tokenAddresses.length; j++) {\n                index = i * tokenAddresses.length + j;\n                balances[index] = IERC20(tokenAddresses[j]).balanceOf(\n                    tokenHolders[i]\n                );\n            }\n        }\n        return balances;\n    }\n\n    /**\n     * @dev Get a batch of ERC1400 token total supplies by partitions.\n     * @param partitions Name of the partitions.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function totalSuppliesByPartition(\n        bytes32[] calldata partitions,\n        address[] calldata tokenAddresses\n    ) external view returns (uint256[] memory) {\n        uint256[] memory partitionSupplies = new uint256[](\n            partitions.length * tokenAddresses.length\n        );\n        uint256 index;\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            for (uint256 j = 0; j < partitions.length; j++) {\n                index = i * partitions.length + j;\n                partitionSupplies[index] = IERC1400Extended(tokenAddresses[i])\n                    .totalSupplyByPartition(partitions[j]);\n            }\n        }\n        return partitionSupplies;\n    }\n\n    /**\n     * @dev Get a batch of ERC20 token total supplies.\n     * @param tokenAddresses Addresses of tokens where the balances need to be fetched.\n     * @return Balances array.\n     */\n    function totalSupplies(address[] calldata tokenAddresses)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory supplies = new uint256[](tokenAddresses.length);\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            supplies[i] = IERC20(tokenAddresses[i]).totalSupply();\n        }\n        return supplies;\n    }\n}\n"
    },
    "contracts/extensions/tokenExtensions/ERC1400TokensValidator.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../roles/Pausable.sol\";\nimport \"../../roles/CertificateSignerRole.sol\";\nimport \"../../roles/AllowlistedRole.sol\";\nimport \"../../roles/BlocklistedRole.sol\";\n\nimport \"../../ERC1820/ERC1820Client.sol\";\nimport \"../../interface/ERC1820Implementer.sol\";\n\nimport \"../../IERC1400.sol\";\n\nimport \"./IERC1400TokensValidator.sol\";\n\n/**\n * @notice Interface to the Minterrole contract\n */\ninterface IMinterRole {\n    function isMinter(address account) external view returns (bool);\n}\n\ncontract ERC1400TokensValidator is\n    IERC1400TokensValidator,\n    Pausable,\n    CertificateSignerRole,\n    AllowlistedRole,\n    BlocklistedRole,\n    ERC1820Client,\n    ERC1820Implementer\n{\n    using SafeMath for uint256;\n\n    string\n        internal constant ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n    bytes4 internal constant ERC20_TRANSFER_ID = bytes4(\n        keccak256(\"transfer(address,uint256)\")\n    );\n    bytes4 internal constant ERC20_TRANSFERFROM_ID = bytes4(\n        keccak256(\"transferFrom(address,address,uint256)\")\n    );\n\n    // Mapping from token to token controllers.\n    mapping(address => address[]) internal _tokenControllers;\n\n    // Mapping from (token, operator) to token controller status.\n    mapping(address => mapping(address => bool)) internal _isTokenController;\n\n    // Mapping from token to allowlist activation status.\n    mapping(address => bool) internal _allowlistActivated;\n\n    // Mapping from token to blocklist activation status.\n    mapping(address => bool) internal _blocklistActivated;\n\n    // Mapping from token to certificate activation status.\n    mapping(address => CertificateValidation) internal _certificateActivated;\n\n    enum CertificateValidation {None, NonceBased, SaltBased}\n\n    // Mapping from (token, certificateNonce) to \"used\" status to ensure a certificate can be used only once\n    mapping(address => mapping(address => uint256))\n        internal _usedCertificateNonce;\n\n    // Mapping from (token, certificateSalt) to \"used\" status to ensure a certificate can be used only once\n    mapping(address => mapping(bytes32 => bool)) internal _usedCertificateSalt;\n\n    // Mapping from token to partition granularity activation status.\n    mapping(address => bool) internal _granularityByPartitionActivated;\n\n    // Mapping from token to holds activation status.\n    mapping(address => bool) internal _holdsActivated;\n\n    enum HoldStatusCode {\n        Nonexistent,\n        Ordered,\n        Executed,\n        ExecutedAndKeptOpen,\n        ReleasedByNotary,\n        ReleasedByPayee,\n        ReleasedOnExpiration\n    }\n\n    struct Hold {\n        bytes32 partition;\n        address sender;\n        address recipient;\n        address notary;\n        uint256 value;\n        uint256 expiration;\n        bytes32 secretHash;\n        bytes32 secret;\n        HoldStatusCode status;\n    }\n\n    // Mapping from (token, partition) to partition granularity.\n    mapping(address => mapping(bytes32 => uint256))\n        internal _granularityByPartition;\n\n    // Mapping from (token, holdId) to hold.\n    mapping(address => mapping(bytes32 => Hold)) internal _holds;\n\n    // Mapping from (token, tokenHolder) to balance on hold.\n    mapping(address => mapping(address => uint256)) internal _heldBalance;\n\n    // Mapping from (token, tokenHolder, partition) to balance on hold of corresponding partition.\n    mapping(address => mapping(address => mapping(bytes32 => uint256)))\n        internal _heldBalanceByPartition;\n\n    // Mapping from (token, partition) to global balance on hold of corresponding partition.\n    mapping(address => mapping(bytes32 => uint256))\n        internal _totalHeldBalanceByPartition;\n\n    // Total balance on hold.\n    mapping(address => uint256) internal _totalHeldBalance;\n\n    // Mapping from hold parameter's hash to hold's nonce.\n    mapping(bytes32 => uint256) internal _hashNonce;\n\n    // Mapping from (hash, nonce) to hold ID.\n    mapping(bytes32 => mapping(uint256 => bytes32)) internal _holdIds;\n\n    event HoldCreated(\n        address indexed token,\n        bytes32 indexed holdId,\n        bytes32 partition,\n        address sender,\n        address recipient,\n        address indexed notary,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash\n    );\n    event HoldReleased(\n        address indexed token,\n        bytes32 holdId,\n        address indexed notary,\n        HoldStatusCode status\n    );\n    event HoldRenewed(\n        address indexed token,\n        bytes32 holdId,\n        address indexed notary,\n        uint256 oldExpiration,\n        uint256 newExpiration\n    );\n    event HoldExecuted(\n        address indexed token,\n        bytes32 holdId,\n        address indexed notary,\n        uint256 heldValue,\n        uint256 transferredValue,\n        bytes32 secret\n    );\n    event HoldExecutedAndKeptOpen(\n        address indexed token,\n        bytes32 holdId,\n        address indexed notary,\n        uint256 heldValue,\n        uint256 transferredValue,\n        bytes32 secret\n    );\n\n    /**\n     * @dev Modifier to verify if sender is a token controller.\n     */\n    modifier onlyTokenController(address token) {\n        require(\n            msg.sender == token ||\n                msg.sender == Ownable(token).owner() ||\n                _isTokenController[token][msg.sender],\n            \"Sender is not a token controller.\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is a pauser.\n     */\n    modifier onlyPauser(address token) {\n        require(\n            msg.sender == token ||\n                msg.sender == Ownable(token).owner() ||\n                _isTokenController[token][msg.sender] ||\n                isPauser(token, msg.sender),\n            \"Sender is not a pauser\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is a pauser.\n     */\n    modifier onlyCertificateSigner(address token) {\n        require(\n            msg.sender == token ||\n                msg.sender == Ownable(token).owner() ||\n                _isTokenController[token][msg.sender] ||\n                isCertificateSigner(token, msg.sender),\n            \"Sender is not a certificate signer\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is an allowlist admin.\n     */\n    modifier onlyAllowlistAdmin(address token) {\n        require(\n            msg.sender == token ||\n                msg.sender == Ownable(token).owner() ||\n                _isTokenController[token][msg.sender] ||\n                isAllowlistAdmin(token, msg.sender),\n            \"Sender is not an allowlist admin\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to verify if sender is a blocklist admin.\n     */\n    modifier onlyBlocklistAdmin(address token) {\n        require(\n            msg.sender == token ||\n                msg.sender == Ownable(token).owner() ||\n                _isTokenController[token][msg.sender] ||\n                isBlocklistAdmin(token, msg.sender),\n            \"Sender is not a blocklist admin\"\n        );\n        _;\n    }\n\n    constructor() public {\n        ERC1820Implementer._setInterface(ERC1400_TOKENS_VALIDATOR);\n    }\n\n    /**\n     * @dev Get the list of token controllers for a given token.\n     * @return Setup of a given token.\n     */\n    function retrieveTokenSetup(address token)\n        external\n        view\n        returns (\n            CertificateValidation,\n            bool,\n            bool,\n            bool,\n            bool,\n            address[] memory\n        )\n    {\n        return (\n            _certificateActivated[token],\n            _allowlistActivated[token],\n            _blocklistActivated[token],\n            _granularityByPartitionActivated[token],\n            _holdsActivated[token],\n            _tokenControllers[token]\n        );\n    }\n\n    /**\n     * @dev Register token setup.\n     */\n    function registerTokenSetup(\n        address token,\n        CertificateValidation certificateActivated,\n        bool allowlistActivated,\n        bool blocklistActivated,\n        bool granularityByPartitionActivated,\n        bool holdsActivated,\n        address[] calldata operators\n    ) external onlyTokenController(token) {\n        _certificateActivated[token] = certificateActivated;\n        _allowlistActivated[token] = allowlistActivated;\n        _blocklistActivated[token] = blocklistActivated;\n        _granularityByPartitionActivated[token] = granularityByPartitionActivated;\n        _holdsActivated[token] = holdsActivated;\n        _setTokenControllers(token, operators);\n    }\n\n    /**\n     * @dev Set list of token controllers for a given token.\n     * @param token Token address.\n     * @param operators Operators addresses.\n     */\n    function _setTokenControllers(address token, address[] memory operators)\n        internal\n    {\n        for (uint256 i = 0; i < _tokenControllers[token].length; i++) {\n            _isTokenController[token][_tokenControllers[token][i]] = false;\n        }\n        for (uint256 j = 0; j < operators.length; j++) {\n            _isTokenController[token][operators[j]] = true;\n        }\n        _tokenControllers[token] = operators;\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @param token Token address.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition (left empty for ERC20 transfer).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     */\n    function canValidate(\n        address token,\n        bytes calldata payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData // Comments to avoid compilation warnings for unused variables.\n    ) external view returns (bool) {\n        (bool canValidateToken, , ) = _canValidateCertificateToken(\n            token,\n            payload,\n            operator,\n            operatorData.length != 0 ? operatorData : data\n        );\n\n        canValidateToken =\n            canValidateToken &&\n            _canValidateAllowlistAndBlocklistToken(token, payload, from, to);\n\n        canValidateToken = canValidateToken && !paused(token);\n\n        canValidateToken =\n            canValidateToken &&\n            _canValidateGranularToken(token, partition, value);\n\n        canValidateToken =\n            canValidateToken &&\n            _canValidateHoldableToken(\n                token,\n                partition,\n                operator,\n                from,\n                to,\n                value\n            );\n\n        return canValidateToken;\n    }\n\n    /**\n     * @dev Function called by the token contract before executing a transfer.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition (left empty for ERC20 transfer).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     */\n    function tokensToValidate(\n        bytes calldata payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData // Comments to avoid compilation warnings for unused variables.\n    ) external {\n        (\n            bool canValidateCertificateToken,\n            CertificateValidation certificateControl,\n            bytes32 salt\n        ) = _canValidateCertificateToken(\n            msg.sender,\n            payload,\n            operator,\n            operatorData.length != 0 ? operatorData : data\n        );\n        require(canValidateCertificateToken, \"54\"); // 0x54\ttransfers halted (contract paused)\n\n        _useCertificateIfActivated(\n            msg.sender,\n            certificateControl,\n            operator,\n            salt\n        );\n\n        require(\n            _canValidateAllowlistAndBlocklistToken(\n                msg.sender,\n                payload,\n                from,\n                to\n            ),\n            \"54\"\n        ); // 0x54\ttransfers halted (contract paused)\n\n        require(!paused(msg.sender), \"54\"); // 0x54\ttransfers halted (contract paused)\n\n        require(_canValidateGranularToken(msg.sender, partition, value), \"50\"); // 0x50\ttransfer failure\n\n        require(\n            _canValidateHoldableToken(\n                msg.sender,\n                partition,\n                operator,\n                from,\n                to,\n                value\n            ),\n            \"55\"\n        ); // 0x55\tfunds locked (lockup period)\n\n        (, , bytes32 holdId) = _retrieveHoldHashNonceId(\n            msg.sender,\n            partition,\n            operator,\n            from,\n            to,\n            value\n        );\n        if (_holdsActivated[msg.sender] && holdId != \"\") {\n            Hold storage executableHold = _holds[msg.sender][holdId];\n            _setHoldToExecuted(\n                msg.sender,\n                executableHold,\n                holdId,\n                value,\n                executableHold.value,\n                \"\"\n            );\n        }\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     * @return hold ID in case a hold can be executed for the given parameters.\n     */\n    function _canValidateCertificateToken(\n        address token,\n        bytes memory payload,\n        address operator,\n        bytes memory certificate\n    )\n        internal\n        view\n        returns (\n            bool,\n            CertificateValidation,\n            bytes32\n        )\n    {\n        if (\n            _certificateActivated[token] > CertificateValidation.None &&\n            _functionSupportsCertificateValidation(payload) &&\n            !isCertificateSigner(token, operator) &&\n            address(this) != operator\n        ) {\n            if (\n                _certificateActivated[token] == CertificateValidation.SaltBased\n            ) {\n                (bool valid, bytes32 salt) = _checkSaltBasedCertificate(\n                    token,\n                    operator,\n                    payload,\n                    certificate\n                );\n                if (valid) {\n                    return (true, CertificateValidation.SaltBased, salt);\n                } else {\n                    return (false, CertificateValidation.SaltBased, \"\");\n                }\n            } else {\n                // case when _certificateActivated[token] == CertificateValidation.NonceBased\n                if (\n                    _checkNonceBasedCertificate(\n                        token,\n                        operator,\n                        payload,\n                        certificate\n                    )\n                ) {\n                    return (true, CertificateValidation.NonceBased, \"\");\n                } else {\n                    return (false, CertificateValidation.SaltBased, \"\");\n                }\n            }\n        }\n\n        return (true, CertificateValidation.None, \"\");\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     * @return hold ID in case a hold can be executed for the given parameters.\n     */\n    function _canValidateAllowlistAndBlocklistToken(\n        address token,\n        bytes memory payload,\n        address from,\n        address to // Comments to avoid compilation warnings for unused variables.\n    ) internal view returns (bool) {\n        if (\n            !_functionSupportsCertificateValidation(payload) ||\n            _certificateActivated[token] == CertificateValidation.None\n        ) {\n            if (_allowlistActivated[token]) {\n                if (from != address(0) && !isAllowlisted(token, from)) {\n                    return false;\n                }\n                if (to != address(0) && !isAllowlisted(token, to)) {\n                    return false;\n                }\n            }\n            if (_blocklistActivated[token]) {\n                if (from != address(0) && isBlocklisted(token, from)) {\n                    return false;\n                }\n                if (to != address(0) && isBlocklisted(token, to)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     * @return hold ID in case a hold can be executed for the given parameters.\n     */\n    function _canValidateGranularToken(\n        address token,\n        bytes32 partition,\n        uint256 value\n    ) internal view returns (bool) {\n        if (_granularityByPartitionActivated[token]) {\n            if (\n                _granularityByPartition[token][partition] > 0 &&\n                !_isMultiple(_granularityByPartition[token][partition], value)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     * @return hold ID in case a hold can be executed for the given parameters.\n     */\n    function _canValidateHoldableToken(\n        address token,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value\n    ) internal view returns (bool) {\n        if (_holdsActivated[token] && from != address(0)) {\n            if (operator != from) {\n                (, , bytes32 holdId) = _retrieveHoldHashNonceId(\n                    token,\n                    partition,\n                    operator,\n                    from,\n                    to,\n                    value\n                );\n                Hold storage hold = _holds[token][holdId];\n\n                if (\n                    _holdCanBeExecutedAsNotary(hold, operator, value) &&\n                    value <=\n                    IERC1400(token).balanceOfByPartition(partition, from)\n                ) {\n                    return true;\n                }\n            }\n\n            if (\n                value > _spendableBalanceOfByPartition(token, partition, from)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Get granularity for a given partition.\n     * @param token Token address.\n     * @param partition Name of the partition.\n     * @return Granularity of the partition.\n     */\n    function granularityByPartition(address token, bytes32 partition)\n        external\n        view\n        returns (uint256)\n    {\n        return _granularityByPartition[token][partition];\n    }\n\n    /**\n     * @dev Set partition granularity\n     */\n    function setGranularityByPartition(\n        address token,\n        bytes32 partition,\n        uint256 granularity\n    ) external onlyTokenController(token) {\n        _granularityByPartition[token][partition] = granularity;\n    }\n\n    /**\n     * @dev Create a new token pre-hold.\n     */\n    function preHoldFor(\n        address token,\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 timeToExpiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        return\n            _createHold(\n                token,\n                holdId,\n                address(0),\n                recipient,\n                notary,\n                partition,\n                value,\n                _computeExpiration(timeToExpiration),\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token pre-hold with expiration date.\n     */\n    function preHoldForWithExpirationDate(\n        address token,\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        _checkExpiration(expiration);\n\n        return\n            _createHold(\n                token,\n                holdId,\n                address(0),\n                recipient,\n                notary,\n                partition,\n                value,\n                expiration,\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token hold.\n     */\n    function hold(\n        address token,\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 timeToExpiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        return\n            _createHold(\n                token,\n                holdId,\n                msg.sender,\n                recipient,\n                notary,\n                partition,\n                value,\n                _computeExpiration(timeToExpiration),\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token hold with expiration date.\n     */\n    function holdWithExpirationDate(\n        address token,\n        bytes32 holdId,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        _checkExpiration(expiration);\n\n        return\n            _createHold(\n                token,\n                holdId,\n                msg.sender,\n                recipient,\n                notary,\n                partition,\n                value,\n                expiration,\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token hold on behalf of the token holder.\n     */\n    function holdFrom(\n        address token,\n        bytes32 holdId,\n        address sender,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 timeToExpiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        require(sender != address(0), \"Payer address must not be zero address\");\n        return\n            _createHold(\n                token,\n                holdId,\n                sender,\n                recipient,\n                notary,\n                partition,\n                value,\n                _computeExpiration(timeToExpiration),\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token hold with expiration date on behalf of the token holder.\n     */\n    function holdFromWithExpirationDate(\n        address token,\n        bytes32 holdId,\n        address sender,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash,\n        bytes calldata certificate\n    ) external returns (bool) {\n        _checkExpiration(expiration);\n        require(sender != address(0), \"Payer address must not be zero address\");\n\n        return\n            _createHold(\n                token,\n                holdId,\n                sender,\n                recipient,\n                notary,\n                partition,\n                value,\n                expiration,\n                secretHash,\n                certificate\n            );\n    }\n\n    /**\n     * @dev Create a new token hold.\n     */\n    function _createHold(\n        address token,\n        bytes32 holdId,\n        address sender,\n        address recipient,\n        address notary,\n        bytes32 partition,\n        uint256 value,\n        uint256 expiration,\n        bytes32 secretHash,\n        bytes memory certificate\n    ) internal returns (bool) {\n        Hold storage newHold = _holds[token][holdId];\n\n        require(\n            recipient != address(0),\n            \"Payee address must not be zero address\"\n        );\n        require(value != 0, \"Value must be greater than zero\");\n        require(newHold.value == 0, \"This holdId already exists\");\n        require(\n            notary != address(0),\n            \"Notary address must not be zero address\"\n        );\n        require(\n            _canHoldOrCanPreHold(token, msg.sender, sender, certificate),\n            \"A hold can only be created with adapted authorizations\"\n        );\n        if (sender != address(0)) {\n            // hold (tokens already exist)\n            require(\n                value <=\n                    _spendableBalanceOfByPartition(token, partition, sender),\n                \"Amount of the hold can't be greater than the spendable balance of the sender\"\n            );\n        }\n\n        newHold.partition = partition;\n        newHold.sender = sender;\n        newHold.recipient = recipient;\n        newHold.notary = notary;\n        newHold.value = value;\n        newHold.expiration = expiration;\n        newHold.secretHash = secretHash;\n        newHold.status = HoldStatusCode.Ordered;\n\n        if (sender != address(0)) {\n            // In case tokens already exist, increase held balance\n            _increaseHeldBalance(token, newHold, holdId);\n        }\n\n        emit HoldCreated(\n            token,\n            holdId,\n            partition,\n            sender,\n            recipient,\n            notary,\n            value,\n            expiration,\n            secretHash\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Release token hold.\n     */\n    function releaseHold(address token, bytes32 holdId)\n        external\n        returns (bool)\n    {\n        return _releaseHold(token, holdId);\n    }\n\n    /**\n     * @dev Release token hold.\n     */\n    function _releaseHold(address token, bytes32 holdId)\n        internal\n        returns (bool)\n    {\n        Hold storage releasableHold = _holds[token][holdId];\n\n        require(\n            releasableHold.status == HoldStatusCode.Ordered ||\n                releasableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n            \"A hold can only be released in status Ordered or ExecutedAndKeptOpen\"\n        );\n        require(\n            _isExpired(releasableHold.expiration) ||\n                (msg.sender == releasableHold.notary) ||\n                (msg.sender == releasableHold.recipient),\n            \"A not expired hold can only be released by the notary or the payee\"\n        );\n\n        if (_isExpired(releasableHold.expiration)) {\n            releasableHold.status = HoldStatusCode.ReleasedOnExpiration;\n        } else {\n            if (releasableHold.notary == msg.sender) {\n                releasableHold.status = HoldStatusCode.ReleasedByNotary;\n            } else {\n                releasableHold.status = HoldStatusCode.ReleasedByPayee;\n            }\n        }\n\n        if (releasableHold.sender != address(0)) {\n            // In case tokens already exist, decrease held balance\n            _decreaseHeldBalance(token, releasableHold, releasableHold.value);\n        }\n\n        emit HoldReleased(\n            token,\n            holdId,\n            releasableHold.notary,\n            releasableHold.status\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Renew hold.\n     */\n    function renewHold(\n        address token,\n        bytes32 holdId,\n        uint256 timeToExpiration,\n        bytes calldata certificate\n    ) external returns (bool) {\n        return\n            _renewHold(\n                token,\n                holdId,\n                _computeExpiration(timeToExpiration),\n                certificate\n            );\n    }\n\n    /**\n     * @dev Renew hold with expiration time.\n     */\n    function renewHoldWithExpirationDate(\n        address token,\n        bytes32 holdId,\n        uint256 expiration,\n        bytes calldata certificate\n    ) external returns (bool) {\n        _checkExpiration(expiration);\n\n        return _renewHold(token, holdId, expiration, certificate);\n    }\n\n    /**\n     * @dev Renew hold.\n     */\n    function _renewHold(\n        address token,\n        bytes32 holdId,\n        uint256 expiration,\n        bytes memory certificate\n    ) internal returns (bool) {\n        Hold storage renewableHold = _holds[token][holdId];\n\n        require(\n            renewableHold.status == HoldStatusCode.Ordered ||\n                renewableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n            \"A hold can only be renewed in status Ordered or ExecutedAndKeptOpen\"\n        );\n        require(\n            !_isExpired(renewableHold.expiration),\n            \"An expired hold can not be renewed\"\n        );\n\n        require(\n            _canHoldOrCanPreHold(\n                token,\n                msg.sender,\n                renewableHold.sender,\n                certificate\n            ),\n            \"A hold can only be renewed with adapted authorizations\"\n        );\n\n        uint256 oldExpiration = renewableHold.expiration;\n        renewableHold.expiration = expiration;\n\n        emit HoldRenewed(\n            token,\n            holdId,\n            renewableHold.notary,\n            oldExpiration,\n            expiration\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Execute hold.\n     */\n    function executeHold(\n        address token,\n        bytes32 holdId,\n        uint256 value,\n        bytes32 secret\n    ) external returns (bool) {\n        return _executeHold(token, holdId, msg.sender, value, secret, false);\n    }\n\n    /**\n     * @dev Execute hold and keep open.\n     */\n    function executeHoldAndKeepOpen(\n        address token,\n        bytes32 holdId,\n        uint256 value,\n        bytes32 secret\n    ) external returns (bool) {\n        return _executeHold(token, holdId, msg.sender, value, secret, true);\n    }\n\n    /**\n     * @dev Execute hold.\n     */\n    function _executeHold(\n        address token,\n        bytes32 holdId,\n        address operator,\n        uint256 value,\n        bytes32 secret,\n        bool keepOpenIfHoldHasBalance\n    ) internal returns (bool) {\n        Hold storage executableHold = _holds[token][holdId];\n\n        bool canExecuteHold;\n        if (\n            secret != \"\" &&\n            _holdCanBeExecutedAsSecretHolder(executableHold, value, secret)\n        ) {\n            executableHold.secret = secret;\n            canExecuteHold = true;\n        } else if (\n            _holdCanBeExecutedAsNotary(executableHold, operator, value)\n        ) {\n            canExecuteHold = true;\n        }\n\n        if (canExecuteHold) {\n            if (\n                keepOpenIfHoldHasBalance && ((executableHold.value - value) > 0)\n            ) {\n                _setHoldToExecutedAndKeptOpen(\n                    token,\n                    executableHold,\n                    holdId,\n                    value,\n                    value,\n                    secret\n                );\n            } else {\n                _setHoldToExecuted(\n                    token,\n                    executableHold,\n                    holdId,\n                    value,\n                    executableHold.value,\n                    secret\n                );\n            }\n\n            if (executableHold.sender == address(0)) {\n                // pre-hold (tokens do not already exist)\n                IERC1400(token).issueByPartition(\n                    executableHold.partition,\n                    executableHold.recipient,\n                    value,\n                    \"\"\n                );\n            } else {\n                // post-hold (tokens already exist)\n                IERC1400(token).operatorTransferByPartition(\n                    executableHold.partition,\n                    executableHold.sender,\n                    executableHold.recipient,\n                    value,\n                    \"\",\n                    \"\"\n                );\n            }\n        } else {\n            revert(\"hold can not be executed\");\n        }\n    }\n\n    /**\n     * @dev Set hold to executed.\n     */\n    function _setHoldToExecuted(\n        address token,\n        Hold storage executableHold,\n        bytes32 holdId,\n        uint256 value,\n        uint256 heldBalanceDecrease,\n        bytes32 secret\n    ) internal {\n        if (executableHold.sender != address(0)) {\n            // In case tokens already exist, decrease held balance\n            _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n        }\n\n        executableHold.status = HoldStatusCode.Executed;\n\n        emit HoldExecuted(\n            token,\n            holdId,\n            executableHold.notary,\n            executableHold.value,\n            value,\n            secret\n        );\n    }\n\n    /**\n     * @dev Set hold to executed and kept open.\n     */\n    function _setHoldToExecutedAndKeptOpen(\n        address token,\n        Hold storage executableHold,\n        bytes32 holdId,\n        uint256 value,\n        uint256 heldBalanceDecrease,\n        bytes32 secret\n    ) internal {\n        if (executableHold.sender != address(0)) {\n            // In case tokens already exist, decrease held balance\n            _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n        }\n\n        executableHold.status = HoldStatusCode.ExecutedAndKeptOpen;\n        executableHold.value = executableHold.value.sub(value);\n\n        emit HoldExecutedAndKeptOpen(\n            token,\n            holdId,\n            executableHold.notary,\n            executableHold.value,\n            value,\n            secret\n        );\n    }\n\n    /**\n     * @dev Increase held balance.\n     */\n    function _increaseHeldBalance(\n        address token,\n        Hold storage executableHold,\n        bytes32 holdId\n    ) private {\n        _heldBalance[token][executableHold\n            .sender] = _heldBalance[token][executableHold.sender].add(\n            executableHold.value\n        );\n        _totalHeldBalance[token] = _totalHeldBalance[token].add(\n            executableHold.value\n        );\n\n        _heldBalanceByPartition[token][executableHold.sender][executableHold\n            .partition] = _heldBalanceByPartition[token][executableHold\n            .sender][executableHold.partition]\n            .add(executableHold.value);\n        _totalHeldBalanceByPartition[token][executableHold\n            .partition] = _totalHeldBalanceByPartition[token][executableHold\n            .partition]\n            .add(executableHold.value);\n\n        _increaseNonce(token, executableHold, holdId);\n    }\n\n    /**\n     * @dev Decrease held balance.\n     */\n    function _decreaseHeldBalance(\n        address token,\n        Hold storage executableHold,\n        uint256 value\n    ) private {\n        _heldBalance[token][executableHold\n            .sender] = _heldBalance[token][executableHold.sender].sub(value);\n        _totalHeldBalance[token] = _totalHeldBalance[token].sub(value);\n\n        _heldBalanceByPartition[token][executableHold.sender][executableHold\n            .partition] = _heldBalanceByPartition[token][executableHold\n            .sender][executableHold.partition]\n            .sub(value);\n        _totalHeldBalanceByPartition[token][executableHold\n            .partition] = _totalHeldBalanceByPartition[token][executableHold\n            .partition]\n            .sub(value);\n\n        if (executableHold.status == HoldStatusCode.Ordered) {\n            _decreaseNonce(token, executableHold);\n        }\n    }\n\n    /**\n     * @dev Increase nonce.\n     */\n    function _increaseNonce(\n        address token,\n        Hold storage executableHold,\n        bytes32 holdId\n    ) private {\n        (bytes32 holdHash, uint256 nonce, ) = _retrieveHoldHashNonceId(\n            token,\n            executableHold.partition,\n            executableHold.notary,\n            executableHold.sender,\n            executableHold.recipient,\n            executableHold.value\n        );\n        _hashNonce[holdHash] = nonce.add(1);\n        _holdIds[holdHash][nonce.add(1)] = holdId;\n    }\n\n    /**\n     * @dev Decrease nonce.\n     */\n    function _decreaseNonce(address token, Hold storage executableHold)\n        private\n    {\n        (bytes32 holdHash, uint256 nonce, ) = _retrieveHoldHashNonceId(\n            token,\n            executableHold.partition,\n            executableHold.notary,\n            executableHold.sender,\n            executableHold.recipient,\n            executableHold.value\n        );\n        _holdIds[holdHash][nonce] = \"\";\n        _hashNonce[holdHash] = _hashNonce[holdHash].sub(1);\n    }\n\n    /**\n     * @dev Check secret.\n     */\n    function _checkSecret(Hold storage executableHold, bytes32 secret)\n        internal\n        view\n        returns (bool)\n    {\n        if (executableHold.secretHash == sha256(abi.encodePacked(secret))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Compute expiration time.\n     */\n    function _computeExpiration(uint256 timeToExpiration)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 expiration = 0;\n\n        if (timeToExpiration != 0) {\n            expiration = now.add(timeToExpiration);\n        }\n\n        return expiration;\n    }\n\n    /**\n     * @dev Check expiration time.\n     */\n    function _checkExpiration(uint256 expiration) private view {\n        require(\n            expiration > now || expiration == 0,\n            \"Expiration date must be greater than block timestamp or zero\"\n        );\n    }\n\n    /**\n     * @dev Check is expiration date is past.\n     */\n    function _isExpired(uint256 expiration) internal view returns (bool) {\n        return expiration != 0 && (now >= expiration);\n    }\n\n    /**\n     * @dev Retrieve hold hash, nonce, and ID for given parameters\n     */\n    function _retrieveHoldHashNonceId(\n        address token,\n        bytes32 partition,\n        address notary,\n        address sender,\n        address recipient,\n        uint256 value\n    )\n        internal\n        view\n        returns (\n            bytes32,\n            uint256,\n            bytes32\n        )\n    {\n        // Pack and hash hold parameters\n        bytes32 holdHash = keccak256(\n            abi.encodePacked(token, partition, sender, recipient, notary, value)\n        );\n        uint256 nonce = _hashNonce[holdHash];\n        bytes32 holdId = _holdIds[holdHash][nonce];\n\n        return (holdHash, nonce, holdId);\n    }\n\n    /**\n     * @dev Check if hold can be executed\n     */\n    function _holdCanBeExecuted(Hold storage executableHold, uint256 value)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            !(executableHold.status == HoldStatusCode.Ordered ||\n                executableHold.status == HoldStatusCode.ExecutedAndKeptOpen)\n        ) {\n            return false; // A hold can only be executed in status Ordered or ExecutedAndKeptOpen\n        } else if (value == 0) {\n            return false; // Value must be greater than zero\n        } else if (_isExpired(executableHold.expiration)) {\n            return false; // The hold has already expired\n        } else if (value > executableHold.value) {\n            return false; // The value should be equal or less than the held amount\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Check if hold can be executed as secret holder\n     */\n    function _holdCanBeExecutedAsSecretHolder(\n        Hold storage executableHold,\n        uint256 value,\n        bytes32 secret\n    ) internal view returns (bool) {\n        if (\n            _checkSecret(executableHold, secret) &&\n            _holdCanBeExecuted(executableHold, value)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Check if hold can be executed as notary\n     */\n    function _holdCanBeExecutedAsNotary(\n        Hold storage executableHold,\n        address operator,\n        uint256 value\n    ) internal view returns (bool) {\n        if (\n            executableHold.notary == operator &&\n            _holdCanBeExecuted(executableHold, value)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Retrieve hold data.\n     */\n    function retrieveHoldData(address token, bytes32 holdId)\n        external\n        view\n        returns (\n            bytes32 partition,\n            address sender,\n            address recipient,\n            address notary,\n            uint256 value,\n            uint256 expiration,\n            bytes32 secretHash,\n            bytes32 secret,\n            HoldStatusCode status\n        )\n    {\n        Hold storage retrievedHold = _holds[token][holdId];\n        return (\n            retrievedHold.partition,\n            retrievedHold.sender,\n            retrievedHold.recipient,\n            retrievedHold.notary,\n            retrievedHold.value,\n            retrievedHold.expiration,\n            retrievedHold.secretHash,\n            retrievedHold.secret,\n            retrievedHold.status\n        );\n    }\n\n    /**\n     * @dev Total supply on hold.\n     */\n    function totalSupplyOnHold(address token) external view returns (uint256) {\n        return _totalHeldBalance[token];\n    }\n\n    /**\n     * @dev Total supply on hold for a specific partition.\n     */\n    function totalSupplyOnHoldByPartition(address token, bytes32 partition)\n        external\n        view\n        returns (uint256)\n    {\n        return _totalHeldBalanceByPartition[token][partition];\n    }\n\n    /**\n     * @dev Get balance on hold of a tokenholder.\n     */\n    function balanceOnHold(address token, address account)\n        external\n        view\n        returns (uint256)\n    {\n        return _heldBalance[token][account];\n    }\n\n    /**\n     * @dev Get balance on hold of a tokenholder for a specific partition.\n     */\n    function balanceOnHoldByPartition(\n        address token,\n        bytes32 partition,\n        address account\n    ) external view returns (uint256) {\n        return _heldBalanceByPartition[token][account][partition];\n    }\n\n    /**\n     * @dev Get spendable balance of a tokenholder.\n     */\n    function spendableBalanceOf(address token, address account)\n        external\n        view\n        returns (uint256)\n    {\n        return _spendableBalanceOf(token, account);\n    }\n\n    /**\n     * @dev Get spendable balance of a tokenholder for a specific partition.\n     */\n    function spendableBalanceOfByPartition(\n        address token,\n        bytes32 partition,\n        address account\n    ) external view returns (uint256) {\n        return _spendableBalanceOfByPartition(token, partition, account);\n    }\n\n    /**\n     * @dev Get spendable balance of a tokenholder.\n     */\n    function _spendableBalanceOf(address token, address account)\n        internal\n        view\n        returns (uint256)\n    {\n        return IERC20(token).balanceOf(account) - _heldBalance[token][account];\n    }\n\n    /**\n     * @dev Get spendable balance of a tokenholder for a specific partition.\n     */\n    function _spendableBalanceOfByPartition(\n        address token,\n        bytes32 partition,\n        address account\n    ) internal view returns (uint256) {\n        return\n            IERC1400(token).balanceOfByPartition(partition, account) -\n            _heldBalanceByPartition[token][account][partition];\n    }\n\n    /**\n     * @dev Check if hold (or pre-hold) can be created.\n     * @return 'true' if the operator can create pre-holds, 'false' if not.\n     */\n    function _canHoldOrCanPreHold(\n        address token,\n        address operator,\n        address sender,\n        bytes memory certificate\n    ) internal returns (bool) {\n        (\n            bool canValidateCertificate,\n            CertificateValidation certificateControl,\n            bytes32 salt\n        ) = _canValidateCertificateToken(\n            token,\n            msg.data,\n            operator,\n            certificate\n        );\n        _useCertificateIfActivated(token, certificateControl, operator, salt);\n\n        if (sender != address(0)) {\n            // hold\n            return\n                canValidateCertificate &&\n                (_isTokenController[token][operator] || operator == sender);\n        } else {\n            // pre-hold\n            return\n                canValidateCertificate && IMinterRole(token).isMinter(operator);\n        }\n    }\n\n    /**\n     * @dev Check if validator is activated for the function called in the smart contract.\n     * @param payload Payload of the initial transaction.\n     * @return 'true' if the function requires validation, 'false' if not.\n     */\n    function _functionSupportsCertificateValidation(bytes memory payload)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes4 functionSig = _getFunctionSig(payload);\n        if (\n            _areEqual(functionSig, ERC20_TRANSFER_ID) ||\n            _areEqual(functionSig, ERC20_TRANSFERFROM_ID)\n        ) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Use certificate, if validated.\n     * @param token Token address.\n     * @param certificateControl Type of certificate.\n     * @param msgSender Transaction sender (only for nonce-based certificates).\n     * @param salt Salt extracted from the certificate (only for salt-based certificates).\n     */\n    function _useCertificateIfActivated(\n        address token,\n        CertificateValidation certificateControl,\n        address msgSender,\n        bytes32 salt\n    ) internal {\n        // Declare certificate as used\n        if (certificateControl == CertificateValidation.NonceBased) {\n            _usedCertificateNonce[token][msgSender] += 1;\n        } else if (certificateControl == CertificateValidation.SaltBased) {\n            _usedCertificateSalt[token][salt] = true;\n        }\n    }\n\n    /**\n     * @dev Extract function signature from payload.\n     * @param payload Payload of the initial transaction.\n     * @return Function signature.\n     */\n    function _getFunctionSig(bytes memory payload)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return (bytes4(payload[0]) |\n            (bytes4(payload[1]) >> 8) |\n            (bytes4(payload[2]) >> 16) |\n            (bytes4(payload[3]) >> 24));\n    }\n\n    /**\n     * @dev Check if 2 variables of type bytes4 are identical.\n     * @return 'true' if 2 variables are identical, 'false' if not.\n     */\n    function _areEqual(bytes4 a, bytes4 b) internal pure returns (bool) {\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Check if 'value' is multiple of 'granularity'.\n     * @param granularity The granularity that want's to be checked.\n     * @param value The quantity that want's to be checked.\n     * @return 'true' if 'value' is a multiple of 'granularity'.\n     */\n    function _isMultiple(uint256 granularity, uint256 value)\n        internal\n        pure\n        returns (bool)\n    {\n        return (value.div(granularity).mul(granularity) == value);\n    }\n\n    /**\n     * @dev Get state of certificate (used or not).\n     * @param token Token address.\n     * @param sender Address whom to check the counter of.\n     * @return uint256 Number of transaction already sent for this token contract.\n     */\n    function usedCertificateNonce(address token, address sender)\n        external\n        view\n        returns (uint256)\n    {\n        return _usedCertificateNonce[token][sender];\n    }\n\n    /**\n     * @dev Checks if a nonce-based certificate is correct\n     * @param certificate Certificate to control\n     */\n    function _checkNonceBasedCertificate(\n        address token,\n        address msgSender,\n        bytes memory payloadWithCertificate,\n        bytes memory certificate\n    ) internal view returns (bool) {\n        // Certificate should be 97 bytes long\n        if (certificate.length != 97) {\n            return false;\n        }\n\n        uint256 e;\n        uint8 v;\n\n        // Extract certificate information and expiration time from payload\n        assembly {\n            // Retrieve expirationTime & ECDSA element (v) from certificate which is a 97 long bytes\n            // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n            e := mload(add(certificate, 0x20))\n            v := byte(0, mload(add(certificate, 0x80)))\n        }\n\n        // Certificate should not be expired\n        if (e < now) {\n            return false;\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        // Perform ecrecover to ensure message information corresponds to certificate\n        if (v == 27 || v == 28) {\n            // Extract certificate from payload\n            bytes memory payloadWithoutCertificate = new bytes(\n                payloadWithCertificate.length.sub(160)\n            );\n            for (\n                uint256 i = 0;\n                i < payloadWithCertificate.length.sub(160);\n                i++\n            ) {\n                // replace 4 bytes corresponding to function selector\n                payloadWithoutCertificate[i] = payloadWithCertificate[i];\n            }\n\n            // Pack and hash\n            bytes memory pack = abi.encodePacked(\n                msgSender,\n                token,\n                payloadWithoutCertificate,\n                e,\n                _usedCertificateNonce[token][msgSender]\n            );\n            bytes32 hash = keccak256(pack);\n\n            bytes32 r;\n            bytes32 s;\n            // Extract certificate information and expiration time from payload\n            assembly {\n                // Retrieve ECDSA elements (r, s) from certificate which is a 97 long bytes\n                // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n                r := mload(add(certificate, 0x40))\n                s := mload(add(certificate, 0x60))\n            }\n\n            // Check if certificate match expected transactions parameters\n            if (isCertificateSigner(token, ecrecover(hash, v, r, s))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Get state of certificate (used or not).\n     * @param token Token address.\n     * @param salt First 32 bytes of certificate whose validity is being checked.\n     * @return bool 'true' if certificate is already used, 'false' if not.\n     */\n    function usedCertificateSalt(address token, bytes32 salt)\n        external\n        view\n        returns (bool)\n    {\n        return _usedCertificateSalt[token][salt];\n    }\n\n    /**\n     * @dev Checks if a salt-based certificate is correct\n     * @param certificate Certificate to control\n     */\n    function _checkSaltBasedCertificate(\n        address token,\n        address msgSender,\n        bytes memory payloadWithCertificate,\n        bytes memory certificate\n    ) internal view returns (bool, bytes32) {\n        // Certificate should be 129 bytes long\n        if (certificate.length != 129) {\n            return (false, \"\");\n        }\n\n        bytes32 salt;\n        uint256 e;\n        uint8 v;\n\n        // Extract certificate information and expiration time from payload\n        assembly {\n            // Retrieve expirationTime & ECDSA elements from certificate which is a 97 long bytes\n            // Certificate encoding format is: <salt (32 bytes)>@<expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n            salt := mload(add(certificate, 0x20))\n            e := mload(add(certificate, 0x40))\n            v := byte(0, mload(add(certificate, 0xa0)))\n        }\n\n        // Certificate should not be expired\n        if (e < now) {\n            return (false, \"\");\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        // Perform ecrecover to ensure message information corresponds to certificate\n        if (v == 27 || v == 28) {\n            // Extract certificate from payload\n            bytes memory payloadWithoutCertificate = new bytes(\n                payloadWithCertificate.length.sub(192)\n            );\n            for (\n                uint256 i = 0;\n                i < payloadWithCertificate.length.sub(192);\n                i++\n            ) {\n                // replace 4 bytes corresponding to function selector\n                payloadWithoutCertificate[i] = payloadWithCertificate[i];\n            }\n\n            // Pack and hash\n            bytes memory pack = abi.encodePacked(\n                msgSender,\n                token,\n                payloadWithoutCertificate,\n                e,\n                salt\n            );\n            bytes32 hash = keccak256(pack);\n\n            bytes32 r;\n            bytes32 s;\n            // Extract certificate information and expiration time from payload\n            assembly {\n                // Retrieve ECDSA elements (r, s) from certificate which is a 97 long bytes\n                // Certificate encoding format is: <expirationTime (32 bytes)>@<r (32 bytes)>@<s (32 bytes)>@<v (1 byte)>\n                r := mload(add(certificate, 0x60))\n                s := mload(add(certificate, 0x80))\n            }\n\n            // Check if certificate match expected transactions parameters\n            if (\n                isCertificateSigner(token, ecrecover(hash, v, r, s)) &&\n                !_usedCertificateSalt[token][salt]\n            ) {\n                return (true, salt);\n            }\n        }\n        return (false, \"\");\n    }\n}\n"
    },
    "contracts/roles/Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./PauserRole.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is PauserRole {\n    event Paused(address indexed token, address account);\n    event Unpaused(address indexed token, address account);\n\n    // Mapping from token to token paused status.\n    mapping(address => bool) private _paused;\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused(address token) public view returns (bool) {\n        return _paused[token];\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused(address token) {\n        require(!_paused[token]);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused(address token) {\n        require(_paused[token]);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause(address token) public onlyPauser(token) whenNotPaused(token) {\n        _paused[token] = true;\n        emit Paused(token, msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause(address token) public onlyPauser(token) whenPaused(token) {\n        _paused[token] = false;\n        emit Unpaused(token, msg.sender);\n    }\n}\n"
    },
    "contracts/roles/CertificateSignerRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\n\n/**\n * @title CertificateSignerRole\n * @dev Certificate signers are responsible for signing certificates.\n */\ncontract CertificateSignerRole {\n    using Roles for Roles.Role;\n\n    event CertificateSignerAdded(address indexed token, address indexed account);\n    event CertificateSignerRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token certificate signers.\n    mapping(address => Roles.Role) private _certificateSigners;\n\n    constructor () internal {}\n\n    modifier onlyCertificateSigner(address token) {\n        require(isCertificateSigner(token, msg.sender));\n        _;\n    }\n\n    function isCertificateSigner(address token, address account) public view returns (bool) {\n        return _certificateSigners[token].has(account);\n    }\n\n    function addCertificateSigner(address token, address account) public onlyCertificateSigner(token) {\n        _addCertificateSigner(token, account);\n    }\n\n    function removeCertificateSigner(address token, address account) public onlyCertificateSigner(token) {\n        _removeCertificateSigner(token, account);\n    }\n\n    function renounceCertificateSigner(address token) public {\n        _removeCertificateSigner(token, msg.sender);\n    }\n\n    function _addCertificateSigner(address token, address account) internal {\n        _certificateSigners[token].add(account);\n        emit CertificateSignerAdded(token, account);\n    }\n\n    function _removeCertificateSigner(address token, address account) internal {\n        _certificateSigners[token].remove(account);\n        emit CertificateSignerRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/AllowlistedRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\nimport \"./AllowlistAdminRole.sol\";\n\n\n/**\n * @title AllowlistedRole\n * @dev Allowlisted accounts have been forbidden by a AllowlistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are AllowlistAdmins (who can also remove\n * it), and not Allowlisteds themselves.\n */\ncontract AllowlistedRole is AllowlistAdminRole {\n    using Roles for Roles.Role;\n\n    event AllowlistedAdded(address indexed token, address indexed account);\n    event AllowlistedRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token allowlisteds.\n    mapping(address => Roles.Role) private _allowlisteds;\n\n    modifier onlyNotAllowlisted(address token) {\n        require(!isAllowlisted(token, msg.sender));\n        _;\n    }\n\n    function isAllowlisted(address token, address account) public view returns (bool) {\n        return _allowlisteds[token].has(account);\n    }\n\n    function addAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n        _addAllowlisted(token, account);\n    }\n\n    function removeAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n        _removeAllowlisted(token, account);\n    }\n\n    function _addAllowlisted(address token, address account) internal {\n        _allowlisteds[token].add(account);\n        emit AllowlistedAdded(token, account);\n    }\n\n    function _removeAllowlisted(address token, address account) internal {\n        _allowlisteds[token].remove(account);\n        emit AllowlistedRemoved(token, account);\n    }\n}\n"
    },
    "contracts/roles/BlocklistedRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\nimport \"./BlocklistAdminRole.sol\";\n\n\n/**\n * @title BlocklistedRole\n * @dev Blocklisted accounts have been forbidden by a BlocklistAdmin to perform certain actions (e.g. participate in a\n * crowdsale). This role is special in that the only accounts that can add it are BlocklistAdmins (who can also remove\n * it), and not Blocklisteds themselves.\n */\ncontract BlocklistedRole is BlocklistAdminRole {\n    using Roles for Roles.Role;\n\n    event BlocklistedAdded(address indexed token, address indexed account);\n    event BlocklistedRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token blocklisteds.\n    mapping(address => Roles.Role) private _blocklisteds;\n\n    modifier onlyNotBlocklisted(address token) {\n        require(!isBlocklisted(token, msg.sender));\n        _;\n    }\n\n    function isBlocklisted(address token, address account) public view returns (bool) {\n        return _blocklisteds[token].has(account);\n    }\n\n    function addBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n        _addBlocklisted(token, account);\n    }\n\n    function removeBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n        _removeBlocklisted(token, account);\n    }\n\n    function _addBlocklisted(address token, address account) internal {\n        _blocklisteds[token].add(account);\n        emit BlocklistedAdded(token, account);\n    }\n\n    function _removeBlocklisted(address token, address account) internal {\n        _blocklisteds[token].remove(account);\n        emit BlocklistedRemoved(token, account);\n    }\n}\n"
    },
    "contracts/roles/PauserRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\n\n/**\n * @title PauserRole\n * @dev Pausers are responsible for pausing/unpausing transfers.\n */\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed token, address indexed account);\n    event PauserRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token pausers.\n    mapping(address => Roles.Role) private _pausers;\n\n    constructor () internal {}\n\n    modifier onlyPauser(address token) {\n        require(isPauser(token, msg.sender));\n        _;\n    }\n\n    function isPauser(address token, address account) public view returns (bool) {\n        return _pausers[token].has(account);\n    }\n\n    function addPauser(address token, address account) public onlyPauser(token) {\n        _addPauser(token, account);\n    }\n\n    function removePauser(address token, address account) public onlyPauser(token) {\n        _removePauser(token, account);\n    }\n\n    function renouncePauser(address token) public {\n        _removePauser(token, msg.sender);\n    }\n\n    function _addPauser(address token, address account) internal {\n        _pausers[token].add(account);\n        emit PauserAdded(token, account);\n    }\n\n    function _removePauser(address token, address account) internal {\n        _pausers[token].remove(account);\n        emit PauserRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/AllowlistAdminRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\n\n/**\n * @title AllowlistAdminRole\n * @dev AllowlistAdmins are responsible for assigning and removing Allowlisted accounts.\n */\ncontract AllowlistAdminRole {\n    using Roles for Roles.Role;\n\n    event AllowlistAdminAdded(address indexed token, address indexed account);\n    event AllowlistAdminRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token allowlist admins.\n    mapping(address => Roles.Role) private _allowlistAdmins;\n\n    constructor () internal {}\n\n    modifier onlyAllowlistAdmin(address token) {\n        require(isAllowlistAdmin(token, msg.sender));\n        _;\n    }\n\n    function isAllowlistAdmin(address token, address account) public view returns (bool) {\n        return _allowlistAdmins[token].has(account);\n    }\n\n    function addAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\n        _addAllowlistAdmin(token, account);\n    }\n\n    function removeAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\n        _removeAllowlistAdmin(token, account);\n    }\n\n    function renounceAllowlistAdmin(address token) public {\n        _removeAllowlistAdmin(token, msg.sender);\n    }\n\n    function _addAllowlistAdmin(address token, address account) internal {\n        _allowlistAdmins[token].add(account);\n        emit AllowlistAdminAdded(token, account);\n    }\n\n    function _removeAllowlistAdmin(address token, address account) internal {\n        _allowlistAdmins[token].remove(account);\n        emit AllowlistAdminRemoved(token, account);\n    }\n}"
    },
    "contracts/roles/BlocklistAdminRole.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\n\n/**\n * @title BlocklistAdminRole\n * @dev BlocklistAdmins are responsible for assigning and removing Blocklisted accounts.\n */\ncontract BlocklistAdminRole {\n    using Roles for Roles.Role;\n\n    event BlocklistAdminAdded(address indexed token, address indexed account);\n    event BlocklistAdminRemoved(address indexed token, address indexed account);\n\n    // Mapping from token to token blocklist admins.\n    mapping(address => Roles.Role) private _blocklistAdmins;\n\n    constructor () internal {}\n\n    modifier onlyBlocklistAdmin(address token) {\n        require(isBlocklistAdmin(token, msg.sender));\n        _;\n    }\n\n    function isBlocklistAdmin(address token, address account) public view returns (bool) {\n        return _blocklistAdmins[token].has(account);\n    }\n\n    function addBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\n        _addBlocklistAdmin(token, account);\n    }\n\n    function removeBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\n        _removeBlocklistAdmin(token, account);\n    }\n\n    function renounceBlocklistAdmin(address token) public {\n        _removeBlocklistAdmin(token, msg.sender);\n    }\n\n    function _addBlocklistAdmin(address token, address account) internal {\n        _blocklistAdmins[token].add(account);\n        emit BlocklistAdminAdded(token, account);\n    }\n\n    function _removeBlocklistAdmin(address token, address account) internal {\n        _blocklistAdmins[token].remove(account);\n        emit BlocklistAdminRemoved(token, account);\n    }\n}"
    },
    "contracts/mocks/ERC1400TokensValidatorMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../extensions/tokenExtensions/ERC1400TokensValidator.sol\";\n\n/**\n @notice Interface to the Minterrole contract\n*/\ninterface IMinterMock {\n  function renounceMinter() external;\n}\n\ncontract ERC1400TokensValidatorMock is ERC1400TokensValidator {\n\n  function renounceMinter(address token) external onlyTokenController(token) {\n    IMinterMock(token).renounceMinter();\n  }\n\n}"
    },
    "contracts/extensions/tokenExtensions/ERC1400TokensChecker.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../ERC1820/ERC1820Client.sol\";\nimport \"../../interface/ERC1820Implementer.sol\";\n\nimport \"../../IERC1400.sol\";\n\nimport \"../userExtensions/IERC1400TokensSender.sol\";\nimport \"../userExtensions/IERC1400TokensRecipient.sol\";\n\nimport \"./IERC1400TokensValidator.sol\";\nimport \"./IERC1400TokensChecker.sol\";\n\ninterface IERC1400Extended {\n    // Not a real interface but added here since 'granularity' doesn't belong to IERC1400\n\n    function granularity() external view returns (uint256);\n}\n\ncontract ERC1400TokensChecker is\n    IERC1400TokensChecker,\n    ERC1820Client,\n    ERC1820Implementer\n{\n    using SafeMath for uint256;\n\n    string\n        internal constant ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n    string internal constant ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\n\n    string internal constant ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n    string\n        internal constant ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n    constructor() public {\n        ERC1820Implementer._setInterface(ERC1400_TOKENS_CHECKER);\n    }\n\n    /**\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition.\n     * @param operator The address performing the transfer.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @param operatorData Information attached to the transfer, by the operator (if any).\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n     * @return Additional bytes32 parameter that can be used to define\n     * application specific reason codes with additional details (for example the\n     * transfer restriction rule responsible for making the transfer operation invalid).\n     * @return Destination partition.\n     */\n    function canTransferByPartition(\n        bytes calldata payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n        external\n        view\n        returns (\n            bytes1,\n            bytes32,\n            bytes32\n        )\n    {\n        return\n            _canTransferByPartition(\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n    }\n\n    /**\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition.\n     * @param operator The address performing the transfer.\n     * @param from Token holder.\n     * @param to Token recipient.\n     * @param value Number of tokens to transfer.\n     * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n     * @param operatorData Information attached to the transfer, by the operator (if any).\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n     * @return Additional bytes32 parameter that can be used to define\n     * application specific reason codes with additional details (for example the\n     * transfer restriction rule responsible for making the transfer operation invalid).\n     * @return Destination partition.\n     */\n    function _canTransferByPartition(\n        bytes memory payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        view\n        returns (\n            bytes1,\n            bytes32,\n            bytes32\n        )\n    {\n        if (\n            !IERC1400(msg.sender).isOperatorForPartition(\n                partition,\n                operator,\n                from\n            )\n        ) return (hex\"58\", \"\", partition); // 0x58\tinvalid operator (transfer agent)\n\n        if (\n            (IERC20(msg.sender).balanceOf(from) < value) ||\n            (IERC1400(msg.sender).balanceOfByPartition(partition, from) < value)\n        ) return (hex\"52\", \"\", partition); // 0x52\tinsufficient balance\n\n        if (to == address(0)) return (hex\"57\", \"\", partition); // 0x57\tinvalid receiver\n\n        address hookImplementation;\n\n        hookImplementation = ERC1820Client.interfaceAddr(\n            from,\n            ERC1400_TOKENS_SENDER\n        );\n        if (\n            (hookImplementation != address(0)) &&\n            !IERC1400TokensSender(hookImplementation).canTransfer(\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            )\n        ) return (hex\"56\", \"\", partition); // 0x56\tinvalid sender\n\n        hookImplementation = ERC1820Client.interfaceAddr(\n            to,\n            ERC1400_TOKENS_RECIPIENT\n        );\n        if (\n            (hookImplementation != address(0)) &&\n            !IERC1400TokensRecipient(hookImplementation).canReceive(\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            )\n        ) return (hex\"57\", \"\", partition); // 0x57\tinvalid receiver\n\n        hookImplementation = ERC1820Client.interfaceAddr(\n            msg.sender,\n            ERC1400_TOKENS_VALIDATOR\n        );\n        if (\n            (hookImplementation != address(0)) &&\n            !IERC1400TokensValidator(hookImplementation).canValidate(\n                msg.sender,\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            )\n        ) return (hex\"54\", \"\", partition); // 0x54\ttransfers halted (contract paused)\n\n        uint256 granularity = IERC1400Extended(msg.sender).granularity();\n        if (!(value.div(granularity).mul(granularity) == value))\n            return (hex\"50\", \"\", partition); // 0x50\ttransfer failure\n\n        return (hex\"51\", \"\", partition); // 0x51\ttransfer success\n    }\n\n    /**\n     * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n     * @return Additional bytes32 parameter that can be used to define\n     * application specific reason codes with additional details (for example the\n     * transfer restriction rule responsible for making the transfer operation invalid).\n     */\n    // function canTransfer(bytes calldata /*payload*/, address /*operator*/, address /*from*/, address /*to*/, uint256 /*value*/, bytes calldata /*data*/, bytes calldata /*operatorData*/)\n    //   external\n    //   view\n    //   returns (byte, bytes32)\n    // {\n    //   if(!IERC1400(msg.sender).isOperator(operator, from))\n    //      return(hex\"58\", \"\"); // 0x58\tinvalid operator (transfer agent)\n\n    //   byte esc;\n\n    //   bytes32[] memory defaultPartitions = IERC1400(msg.sender).getDefaultPartitions();\n\n    //   if(defaultPartitions.length == 0) {\n    //     return(hex\"55\", \"\"); // 0x55\tfunds locked (lockup period)\n    //   }\n\n    //   uint256 _remainingValue = value;\n    //   uint256 _localBalance;\n\n    //   for (uint i = 0; i < defaultPartitions.length; i++) {\n    //     _localBalance = IERC1400(msg.sender).balanceOfByPartition(defaultPartitions[i], from);\n    //     if(_remainingValue <= _localBalance) {\n    //       (esc,,) = _canTransferByPartition(payload, defaultPartitions[i], operator, from, to, _remainingValue, data, operatorData);\n    //       _remainingValue = 0;\n    //       break;\n    //     } else if (_localBalance != 0) {\n    //       (esc,,) = _canTransferByPartition(payload, defaultPartitions[i], operator, from, to, _localBalance, data, operatorData);\n    //       _remainingValue = _remainingValue - _localBalance;\n    //     }\n    //     if(esc != hex\"51\") {\n    //       return(esc, \"\");\n    //     }\n    //   }\n\n    //   if(_remainingValue != 0) {\n    //     return(hex\"52\", \"\"); // 0x52\tinsufficient balance\n    //   }\n\n    //   return(hex\"51\", \"\"); // 0x51\ttransfer success\n\n    //   return(hex\"00\", \"\");\n    // }\n}\n"
    },
    "contracts/mocks/ERC1400TokensSenderMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../extensions/userExtensions/IERC1400TokensSender.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\n\ncontract ERC1400TokensSenderMock is IERC1400TokensSender, ERC1820Implementer {\n\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\n\n  constructor() public {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_SENDER);\n  }\n\n  function canTransfer(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    view\n    returns(bool)\n  {\n    return(_canTransfer(from, to, value, data));\n  }\n\n  function tokensToTransfer(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n  {\n    require(_canTransfer(from, to, value, data), \"56\"); // 0x56\tinvalid sender\n  }\n\n  function _canTransfer(\n    address /*from*/,\n    address /*to*/,\n    uint /*value*/,\n    bytes memory data\n  ) // Comments to avoid compilation warnings for unused variables.\n    internal\n    pure\n    returns(bool)\n  {\n    bytes32 transferRevert = 0x1100000000000000000000000000000000000000000000000000000000000000; // Default sender hook failure data for the mock only\n    bytes32 data32;\n    assembly {\n        data32 := mload(add(data, 32))\n    }\n    if (data32 == transferRevert) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}"
    },
    "contracts/extensions/tokenExtensions/ERC1400AuthValidator.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../ERC1820/ERC1820Client.sol\";\nimport \"../../interface/ERC1820Implementer.sol\";\n\nimport \"../../IERC1400.sol\";\n\nimport \"../../IAuthProvider.sol\";\n\nimport \"./IERC1400TokensValidator.sol\";\n\n/**\n * @notice Interface to the Minterrole contract\n */\ninterface IMinterRole {\n    function isMinter(address account) external view returns (bool);\n}\n\ncontract ERC1400AuthValidator is\n    IERC1400TokensValidator,\n    ERC1820Client,\n    ERC1820Implementer\n{\n    using SafeMath for uint256;\n\n    string internal constant ERC1400_TOKENS_VALIDATOR =\n        \"ERC1400TokensValidator\";\n    string internal constant ERC1400_AUTH_VALIDATOR = \"ERC1400AuthValidator\";\n    IAuthProvider internal _authProvider;\n\n    constructor(address authProviderAddress) public {\n        ERC1820Implementer._setInterface(ERC1400_TOKENS_VALIDATOR);\n        ERC1820Implementer._setInterface(ERC1400_AUTH_VALIDATOR);\n        _authProvider = IAuthProvider(authProviderAddress);\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @param token Token address.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition (left empty for ERC20 transfer).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     */\n    function canValidate(\n        address token,\n        bytes calldata payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData // Comments to avoid compilation warnings for unused variables.\n    ) external view returns (bool) {\n        return\n            _canValidate(\n                token,\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            );\n    }\n\n    /*\n     * @dev Function called by the token contract before executing a transfer.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition (left empty for ERC20 transfer).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     */\n    function tokensToValidate(\n        bytes calldata payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata operatorData // Comments to avoid compilation warnings for unused variables.\n    ) external {\n        require(\n            _canValidate(\n                msg.sender,\n                payload,\n                partition,\n                operator,\n                from,\n                to,\n                value,\n                data,\n                operatorData\n            ),\n            \"A7\"\n        );\n    }\n\n    /**\n     * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n     * @param token Token address.\n     * @param payload Payload of the initial transaction.\n     * @param partition Name of the partition (left empty for ERC20 transfer).\n     * @param operator Address which triggered the balance decrease (through transfer or redemption).\n     * @param from Token holder.\n     * @param to Token recipient for a transfer and 0x for a redemption.\n     * @param value Number of tokens the token holder balance is decreased by.\n     * @param data Extra information.\n     * @param operatorData Extra information, attached by the operator (if any).\n     * @return 'true' if the token transfer can be validated, 'false' if not.\n     */\n    function _canValidate(\n        address token,\n        bytes memory payload,\n        bytes32 partition,\n        address operator,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data,\n        bytes memory operatorData // Comments to avoid compilation warnings for unused variables.\n    ) internal view returns (bool) {\n        // TODO Auth provider here\n        bool hasAuthenticated =\n            _authProvider.hasAuthenticated(to, now - 365 days);\n        require(\n            hasAuthenticated,\n            \"TO address NOT authenticated in last 365 days.\"\n        );\n        return hasAuthenticated;\n    }\n}\n"
    },
    "contracts/IAuthProvider.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.5.0;\n\ncontract IAuthProvider {\n    function hasAuthenticated(address addr, uint256 latestAcceptedTimestamp)\n        public\n        view\n        returns (bool);\n}\n"
    },
    "contracts/tokens/ERC721Token.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Mintable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Pausable.sol\";\n\nimport \"../interface/ERC1820Implementer.sol\";\n\ncontract ERC721Token is Ownable, ERC721Mintable, ERC721Burnable, ERC721Pausable, ERC721Full, ERC1820Implementer {\n  string constant internal ERC721_TOKEN = \"ERC721Token\";\n\n  constructor(string memory name, string memory symbol) public ERC721Full(name, symbol) {\n    ERC1820Implementer._setInterface(ERC721_TOKEN);\n  }\n\n  /**\n    * @dev Gets the list of token IDs of the requested owner.\n    * @param owner address owning the tokens\n    * @return uint256[] List of token IDs owned by the requested address\n    */\n  function tokensOfOwner(address owner) external view returns (uint256[] memory) {\n    return _tokensOfOwner(owner);\n  }\n\n}"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\n\n/**\n * @title Full ERC721 Token\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\ncontract ERC721Burnable is ERC721 {\n    /**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n    function burn(uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n        _burn(tokenId);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Pausable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"../../lifecycle/Pausable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Pausable token\n * @dev ERC721 modified with pausable transfers.\n **/\ncontract ERC721Pausable is ERC721, Pausable {\n    function approve(address to, uint256 tokenId) public whenNotPaused {\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address to, bool approved) public whenNotPaused {\n        super.setApprovalForAll(to, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\n        super.transferFrom(from, to, tokenId);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721Enumerable.sol\";\nimport \"./ERC721.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n    /**\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\n        // lasTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    /**\n     * 0x5b5e139f ===\n     *     bytes4(keccak256('name()')) ^\n     *     bytes4(keccak256('symbol()')) ^\n     *     bytes4(keccak256('tokenURI(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token\n     * Reverts if the token ID does not exist\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/mocks/BlocklistMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotBlocklisted\" MODIFIER\n\nimport \"../roles/BlocklistedRole.sol\";\n\n\ncontract BlocklistMock is BlocklistedRole {\n\n  bool _mockActivated;\n\n  constructor(address token) public {\n    _addBlocklistAdmin(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyNotBlocklisted(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/mocks/AllowlistMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotAllowlisted\" MODIFIER\n\nimport \"../roles/AllowlistedRole.sol\";\n\n\ncontract AllowlistMock is AllowlistedRole {\n\n  bool _mockActivated;\n\n  constructor(address token) public {\n    _addAllowlistAdmin(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyNotAllowlisted(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/mocks/CertificateSignerMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotPausered\" MODIFIER\n\nimport \"../roles/CertificateSignerRole.sol\";\n\n\ncontract CertificateSignerMock is CertificateSignerRole {\n\n  constructor(address token) public {\n    _addCertificateSigner(token, msg.sender);\n  }\n\n}"
    },
    "contracts/mocks/PauserMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyNotPausered\" MODIFIER\n\nimport \"../roles/PauserRole.sol\";\n\n\ncontract PauserMock is PauserRole {\n\n  bool _mockActivated;\n\n  constructor(address token) public {\n    _addPauser(token, msg.sender);\n  }\n\n  function mockFunction(address token, bool mockActivated) external onlyPauser(token) {\n    _mockActivated = mockActivated;\n  }\n\n}"
    },
    "contracts/capTable/ControllerRole.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\n\ncontract ControllerRole {\n    using Roles for Roles.Role;\n    Roles.Role internal CONTROLLER;\n\n    event controllerAdded(address indexed account);\n    event controllerRemoved(address indexed account);\n\n    /* Contructor */\n    constructor(address[] memory controllers) public {\n        for (uint256 i = 0; i < controllers.length; i++) {\n            CONTROLLER.add(controllers[i]);\n        }\n    }\n\n    function addController(address newController) external onlyControllers {\n        CONTROLLER.add(newController);\n        emit controllerAdded(newController);\n    }\n\n    function removeController(address controllerToRemove)\n        external\n        onlyControllers\n    {\n        CONTROLLER.remove(controllerToRemove);\n        emit controllerRemoved(controllerToRemove);\n    }\n\n    function isController() external view returns (bool) {\n        return CONTROLLER.has(msg.sender);\n    }\n\n    /* Modifiers */\n\n    modifier onlyControllers() {\n        require(CONTROLLER.has(msg.sender), \"msg.sender must be CONTROLLER\");\n        _;\n    }\n}\n"
    },
    "contracts/mocks/MinterRoleMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\n// MOCK CONTRACT TO REACH FULL COVERAGE BY CALLING \"onlyMinter\" MODIFIER\n\nimport \"../roles/MinterRole.sol\";\n\n\ncontract MinterMock is MinterRole {\n\n  constructor() public MinterRole() {}\n\n}"
    },
    "contracts/ERC1820/ExampleClient.sol": {
      "content": "pragma solidity ^0.5.3;\n\nimport \"./ERC1820Client.sol\";\n\n\ncontract ExampleClient is ERC1820Client {\n\n    address private owner;\n\n    constructor() public {\n        setInterfaceImplementation(\"ExampleClient\", address(this));\n        owner = msg.sender;\n    }\n\n    function delegateManager() public {\n        require(owner == msg.sender, \"Not the owner\");\n        delegateManagement(msg.sender);\n    }\n\n}\n"
    },
    "contracts/mocks/ERC1400TokensRecipientMock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../extensions/userExtensions/IERC1400TokensRecipient.sol\";\nimport \"../interface/ERC1820Implementer.sol\";\n\n\ncontract ERC1400TokensRecipientMock is IERC1400TokensRecipient, ERC1820Implementer {\n\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\n\n  constructor() public {\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_RECIPIENT);\n  }\n\n  function canReceive(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n    view\n    returns(bool)\n  {\n    return(_canReceive(from, to, value, data));\n  }\n\n  function tokensReceived(\n    bytes calldata /*payload*/,\n    bytes32 /*partition*/,\n    address /*operator*/,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata /*operatorData*/\n  ) // Comments to avoid compilation warnings for unused variables.\n    external\n  {\n    require(_canReceive(from, to, value, data), \"57\"); // 0x57\tinvalid receiver\n  }\n\n  function _canReceive(\n    address /*from*/,\n    address /*to*/,\n    uint /*value*/,\n    bytes memory data\n  ) // Comments to avoid compilation warnings for unused variables.\n    internal\n    pure\n    returns(bool)\n  {\n    bytes32 receiveRevert = 0x2200000000000000000000000000000000000000000000000000000000000000; // Default recipient hook failure data for the mock only\n    bytes32 data32;\n    assembly {\n        data32 := mload(add(data, 32))\n    }\n    if (data32 == receiveRevert) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}\n"
    },
    "contracts/tokens/ERC1400HoldableToken.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension types\n */\ninterface IExtensionTypes {\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n}\n\n/**\n * @notice Interface to the extension contract\n */\ncontract Extension is IExtensionTypes {\n  function registerTokenSetup(\n    address token,\n    CertificateValidation certificateActivated,\n    bool allowlistActivated,\n    bool blocklistActivated,\n    bool granularityByPartitionActivated,\n    bool holdsActivated,\n    address[] calldata operators\n  ) external;\n}\n\ncontract ERC1400HoldableToken is ERC1400, IExtensionTypes {\n\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n  /**\n   * @dev Initialize ERC1400 + setup the token extension.\n   * @param name Name of the token.\n   * @param symbol Symbol of the token.\n   * @param granularity Granularity of the token.\n   * @param controllers Array of initial controllers.\n   * @param defaultPartitions Partitions chosen by default, when partition is\n   * not specified, like the case ERC20 tranfers.\n   * @param extension Address of token extension.\n   * @param newOwner Address whom contract ownership shall be transferred to.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address newOwner\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      Extension(extension).registerTokenSetup(\n        address(this), // token\n        CertificateValidation.None, // certificateActivated\n        true, // allowlistActivated\n        true, // blocklistActivated\n        true, // granularityByPartitionActivated\n        true, // holdsActivated\n        controllers // token controllers\n      );\n\n      _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\n    }\n\n    if(newOwner != address(0)) {\n      _transferOwnership(newOwner);\n    }\n  }\n\n}"
    },
    "contracts/mocks/FakeERC1400Mock.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension contract\n */\ncontract ExtensionMock {\n  function addCertificateSigner(\n    address token,\n    address account\n  ) external;\n  function addAllowlistAdmin(\n    address token,\n    address account\n  ) external;\n  function addBlocklistAdmin(\n    address token,\n    address account\n  ) external;\n  function addPauser(\n    address token,\n    address account\n  ) external;\n}\n\ncontract FakeERC1400Mock is ERC1400 {\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address mockAddress\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      ExtensionMock(extension).addCertificateSigner(address(this), mockAddress);\n      ExtensionMock(extension).addAllowlistAdmin(address(this), mockAddress);\n      ExtensionMock(extension).addBlocklistAdmin(address(this), mockAddress);\n      ExtensionMock(extension).addPauser(address(this), mockAddress);\n    }\n  }\n\n  /**\n   * Override function to allow calling \"tokensReceived\" hook with wrong recipient (\"to\")\n   */\n  function _callRecipientExtension(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    address recipientImplementation;\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\n\n    if (recipientImplementation != address(0)) {\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, from, value, data, operatorData);\n    }\n  }\n\n  /**\n   * Override function to allow redeeming tokens from address(0)\n   */\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata /*data*/) external {\n    _transferWithData(from, to, value);\n  }\n\n  /**\n   * Override function to allow redeeming tokens from address(0)\n   */\n  function redeemFrom(address from, uint256 value, bytes calldata data)\n    external\n  {\n    _redeem(msg.sender, from, value, data);\n  }\n\n}\n"
    },
    "contracts/certificate/ERC1400HoldableCertificateToken.sol": {
      "content": "/*\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\npragma solidity ^0.5.0;\n\nimport \"../ERC1400.sol\";\n\n/**\n * @notice Interface to the extension types\n */\ninterface IExtensionTypes {\n  enum CertificateValidation {\n    None,\n    NonceBased,\n    SaltBased\n  }\n}\n\n/**\n * @notice Interface to the extension contract\n */\ncontract Extension is IExtensionTypes {\n  function registerTokenSetup(\n    address token,\n    CertificateValidation certificateActivated,\n    bool allowlistActivated,\n    bool blocklistActivated,\n    bool granularityByPartitionActivated,\n    bool holdsActivated,\n    address[] calldata operators\n  ) external;\n\n  function addCertificateSigner(\n    address token,\n    address account\n  ) external;\n}\n\n\n/**\n * @title ERC1400HoldableCertificateNonceToken\n * @dev Holdable ERC1400 with nonce-based certificate controller logic\n */\ncontract ERC1400HoldableCertificateToken is ERC1400, IExtensionTypes {\n\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\n\n  /**\n   * @dev Initialize ERC1400 + initialize certificate controller.\n   * @param name Name of the token.\n   * @param symbol Symbol of the token.\n   * @param granularity Granularity of the token.\n   * @param controllers Array of initial controllers.\n   * @param defaultPartitions Partitions chosen by default, when partition is\n   * not specified, like the case ERC20 tranfers.\n   * @param extension Address of token extension.\n   * @param newOwner Address whom contract ownership shall be transferred to.\n   * @param certificateSigner Address of the off-chain service which signs the\n   * conditional ownership certificates required for token transfers, issuance,\n   * redemption (Cf. CertificateController.sol).\n   * @param certificateActivated If set to 'true', the certificate controller\n   * is activated at contract creation.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    bytes32[] memory defaultPartitions,\n    address extension,\n    address newOwner,\n    address certificateSigner,\n    CertificateValidation certificateActivated\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\n  {\n    if(extension != address(0)) {\n      Extension(extension).registerTokenSetup(\n        address(this), // token\n        certificateActivated, // certificateActivated\n        true, // allowlistActivated\n        true, // blocklistActivated\n        true, // granularityByPartitionActivated\n        true, // holdsActivated\n        controllers // token controllers\n      );\n\n      if(certificateSigner != address(0)) {\n        Extension(extension).addCertificateSigner(address(this), certificateSigner);\n      }\n\n      _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\n    }\n\n    if(newOwner != address(0)) {\n      _transferOwnership(newOwner);\n    }\n  }\n\n  /************************************** Transfer Validity ***************************************/\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param partition Name of the partition.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\n    external\n    view\n    returns (byte, bytes32, bytes32)\n  {\n    return ERC1400._canTransfer(\n      _replaceFunctionSelector(this.transferByPartition.selector, msg.data), // 0xf3d490db: 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\n      partition,\n      msg.sender,\n      msg.sender,\n      to,\n      value,\n      data,\n      \"\"\n    );\n  }\n  /**\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\n   * @param partition Name of the partition.\n   * @param from Token holder.\n   * @param to Token recipient.\n   * @param value Number of tokens to transfer.\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\n   * @return Additional bytes32 parameter that can be used to define\n   * application specific reason codes with additional details (for example the\n   * transfer restriction rule responsible for making the transfer operation invalid).\n   * @return Destination partition.\n   */\n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    view\n    returns (byte, bytes32, bytes32)\n  {\n    return ERC1400._canTransfer(\n      _replaceFunctionSelector(this.operatorTransferByPartition.selector, msg.data), // 0x8c0dee9c: 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\n      partition,\n      msg.sender,\n      from,\n      to,\n      value,\n      data,\n      operatorData\n    );\n  }\n  /**\n   * @dev Replace function selector\n   * @param functionSig Replacement function selector.\n   * @param payload Payload, where function selector needs to be replaced.\n   */\n  function _replaceFunctionSelector(bytes4 functionSig, bytes memory payload) internal pure returns(bytes memory) {\n    bytes memory updatedPayload = new bytes(payload.length);\n    for (uint i = 0; i<4; i++){\n      updatedPayload[i] = functionSig[i];\n    }\n    for (uint j = 4; j<payload.length; j++){\n      updatedPayload[j] = payload[j];\n    }\n    return updatedPayload;\n  }\n  /************************************************************************************************/\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}