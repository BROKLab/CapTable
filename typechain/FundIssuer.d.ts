/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface FundIssuerInterface extends ethers.utils.Interface {
  functions: {
    "priceOracles(address)": FunctionFragment;
    "setPriceOracles(address,address[])": FunctionFragment;
    "getCycleOrders(uint256)": FunctionFragment;
    "getNbCycles()": FunctionFragment;
    "getCycle(uint256)": FunctionFragment;
    "finalizeCycle(uint256)": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "getInvestorOrders(address)": FunctionFragment;
    "getOrderAmountAndValue(uint256)": FunctionFragment;
    "getTotalSettledForCycle(uint256)": FunctionFragment;
    "batchExecutePaymentsAsController(uint256[],bool)": FunctionFragment;
    "getNbOrders()": FunctionFragment;
    "cancelOrder(uint256)": FunctionFragment;
    "getAssetValueRules(address,bytes32)": FunctionFragment;
    "tokenControllers(address)": FunctionFragment;
    "setAssetValueRules(address,bytes32,uint8,uint256,uint256)": FunctionFragment;
    "executePaymentAsInvestor(uint256)": FunctionFragment;
    "getLastCycleIndex(address,bytes32)": FunctionFragment;
    "executePaymentAsController(uint256,bool)": FunctionFragment;
    "getCycleState(uint256)": FunctionFragment;
    "batchSettleOrders(uint256[])": FunctionFragment;
    "rejectOrder(uint256,bool)": FunctionFragment;
    "getOrder(uint256)": FunctionFragment;
    "getAssetRules(address,bytes32)": FunctionFragment;
    "valuate(uint256,uint256,uint256)": FunctionFragment;
    "getCycleAssetValue(uint256)": FunctionFragment;
    "setAssetRules(address,bytes32,uint256,uint256,uint256,uint256,uint8,address,bytes32,address,bool)": FunctionFragment;
    "setTokenControllers(address,address[])": FunctionFragment;
    "subscribe(address,bytes32,uint256,uint256,uint8,bool)": FunctionFragment;
    "tokensReceived(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "canReceive(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracles",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleOrders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbCycles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getInvestorOrders",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderAmountAndValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalSettledForCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "batchExecutePaymentsAsController",
    values: [BigNumberish[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbOrders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetValueRules",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenControllers",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetValueRules",
    values: [string, BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsInvestor",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastCycleIndex",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsController",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "batchSettleOrders",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectOrder",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetRules",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "valuate",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleAssetValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetRules",
    values: [
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BytesLike,
      string,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenControllers",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "subscribe",
    values: [
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensReceived",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "canReceive",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbCycles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCycle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalizeCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInvestorOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOrderAmountAndValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalSettledForCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchExecutePaymentsAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsInvestor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastCycleIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchSettleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "valuate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCycleAssetValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "subscribe", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokensReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canReceive", data: BytesLike): Result;

  events: {};
}

export class FundIssuer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: FundIssuerInterface;

  functions: {
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getNbCycles(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        boolean
      ]
    >;

    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, boolean]>;

    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getNbOrders(overrides?: CallOverrides): Promise<[BigNumber]>;

    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        string,
        boolean
      ]
    >;

    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  priceOracles(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  setPriceOracles(
    tokenAddress: string,
    oracles: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getCycleOrders(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

  getCycle(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      string,
      string,
      boolean
    ]
  >;

  finalizeCycle(
    cycleIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  canImplementInterfaceForAddress(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  getInvestorOrders(
    investor: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getOrderAmountAndValue(
    orderIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getTotalSettledForCycle(
    cycleIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber, boolean]>;

  batchExecutePaymentsAsController(
    orderIndexes: BigNumberish[],
    bypassPayment: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

  cancelOrder(
    orderIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getAssetValueRules(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber, BigNumber]>;

  tokenControllers(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  setAssetValueRules(
    assetAddress: string,
    assetClass: BytesLike,
    assetValueType: BigNumberish,
    assetValue: BigNumberish,
    reverseAssetValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  executePaymentAsInvestor(
    orderIndex: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getLastCycleIndex(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  executePaymentAsController(
    orderIndex: BigNumberish,
    bypassPayment: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getCycleState(
    cycleIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  batchSettleOrders(
    orderIndexes: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rejectOrder(
    orderIndex: BigNumberish,
    rejected: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getOrder(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

  getAssetRules(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      string,
      string,
      string,
      boolean
    ]
  >;

  valuate(
    cycleIndex: BigNumberish,
    assetValue: BigNumberish,
    reverseAssetValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getCycleAssetValue(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber, BigNumber]>;

  setAssetRules(
    assetAddress: string,
    assetClass: BytesLike,
    firstStartTime: BigNumberish,
    subscriptionPeriodLength: BigNumberish,
    valuationPeriodLength: BigNumberish,
    paymentPeriodLength: BigNumberish,
    paymentType: BigNumberish,
    paymentAddress: string,
    paymentPartition: BytesLike,
    fundAddress: string,
    subscriptionsOpened: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTokenControllers(
    tokenAddress: string,
    operators: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  subscribe(
    assetAddress: string,
    assetClass: BytesLike,
    orderValue: BigNumberish,
    orderAmount: BigNumberish,
    orderType: BigNumberish,
    executePaymentAtSubscription: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tokensReceived(
    arg0: BytesLike,
    partition: BytesLike,
    arg2: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  canReceive(
    arg0: BytesLike,
    arg1: BytesLike,
    arg2: string,
    arg3: string,
    arg4: string,
    arg5: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        boolean
      ]
    >;

    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, boolean]>;

    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        string,
        boolean
      ]
    >;

    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {};

  estimateGas: {
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNbCycles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getNbOrders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
